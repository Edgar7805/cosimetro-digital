CCS PCH C Compiler, Version 5.015, 5967               15-dic.-23 12:16

               Filename:   C:\Users\Edgar\Desktop\fimware fp\vercion 13\vercion13.lst

               ROM used:   13362 bytes (41%)
                           Largest free fragment is 19406
               RAM used:   507 (25%) at main() level
                           586 (29%) worst case
               Stack used: 17 locations (8 in main + 9 for interrupts)
               Stack size: 31

*
0000:  GOTO   3042
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF0.3
004A:  GOTO   0054
004E:  BTFSC  FF0.0
0050:  GOTO   13C6
0054:  BTFSS  FF2.4
0056:  GOTO   0060
005A:  BTFSC  FF2.1
005C:  GOTO   1228
0060:  BTFSS  FA0.5
0062:  GOTO   006C
0066:  BTFSC  FA1.5
0068:  GOTO   11AA
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18f4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA 02,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 00,FF
00E0:  DATA 02,FF
00E2:  DATA FF,FF
00E4:  DATA FF,FF
00E6:  DATA FF,FF
00E8:  DATA FF,FF
00EA:  DATA FF,FF
00EC:  DATA FF,FF
00EE:  CLRF   FF7
00F0:  ADDLW  FE
00F2:  MOVWF  FF6
00F4:  MOVLW  00
00F6:  ADDWFC FF7,F
00F8:  TBLRD*+
00FA:  MOVF   FF5,W
00FC:  RETURN 0
00FE:  DATA 40,00
0100:  DATA 0B,00
0102:  DATA 40,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 00,00
010C:  DATA 00,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  CLRF   FF7
0120:  ADDLW  2E
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  RETURN 0
012E:  DATA 40,00
0130:  DATA 00,00
0132:  DATA 40,00
0134:  DATA 00,00
0136:  DATA 00,00
0138:  DATA 00,00
013A:  DATA 00,00
013C:  DATA 00,00
013E:  DATA 00,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  CLRF   FF7
0150:  ADDLW  5E
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  ADDWFC FF7,F
0158:  TBLRD*+
015A:  MOVF   FF5,W
015C:  RETURN 0
015E:  DATA 09,02
0160:  DATA 43,00
0162:  DATA 02,01
0164:  DATA 00,80
0166:  DATA 32,09
0168:  DATA 04,00
016A:  DATA 00,01
016C:  DATA 02,02
016E:  DATA 01,00
0170:  DATA 05,24
0172:  DATA 00,10
0174:  DATA 01,04
0176:  DATA 24,02
0178:  DATA 02,05
017A:  DATA 24,06
017C:  DATA 00,01
017E:  DATA 05,24
0180:  DATA 01,00
0182:  DATA 01,07
0184:  DATA 05,81
0186:  DATA 03,0B
0188:  DATA 00,FA
018A:  DATA 09,04
018C:  DATA 01,00
018E:  DATA 02,0A
0190:  DATA 00,00
0192:  DATA 00,07
0194:  DATA 05,02
0196:  DATA 02,40
0198:  DATA 00,01
019A:  DATA 07,05
019C:  DATA 82,02
019E:  DATA 40,00
01A0:  DATA 01,00
01A2:  CLRF   FF7
01A4:  ADDLW  B2
01A6:  MOVWF  FF6
01A8:  MOVLW  01
01AA:  ADDWFC FF7,F
01AC:  TBLRD*+
01AE:  MOVF   FF5,W
01B0:  RETURN 0
01B2:  DATA 02,00
01B4:  CLRF   FF7
01B6:  ADDLW  C4
01B8:  MOVWF  FF6
01BA:  MOVLW  01
01BC:  ADDWFC FF7,F
01BE:  TBLRD*+
01C0:  MOVF   FF5,W
01C2:  RETURN 0
01C4:  DATA 12,17
01C6:  DATA 1B,20
01C8:  DATA FF,FF
01CA:  DATA FF,FF
01CC:  CLRF   FF7
01CE:  ADDLW  DC
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  RETURN 0
01DC:  DATA 12,01
01DE:  DATA 10,01
01E0:  DATA 02,00
01E2:  DATA 00,40
01E4:  DATA 05,24
01E6:  DATA 0B,00
01E8:  DATA 00,01
01EA:  DATA 01,02
01EC:  DATA 00,01
01EE:  CLRF   FF7
01F0:  ADDLW  FE
01F2:  MOVWF  FF6
01F4:  MOVLW  01
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  RETURN 0
01FE:  DATA 04,03
0200:  DATA 09,04
0202:  DATA 08,03
0204:  DATA 43,00
0206:  DATA 43,00
0208:  DATA 53,00
020A:  DATA 20,03
020C:  DATA 43,00
020E:  DATA 43,00
0210:  DATA 53,00
0212:  DATA 20,00
0214:  DATA 55,00
0216:  DATA 53,00
0218:  DATA 42,00
021A:  DATA 20,00
021C:  DATA 74,00
021E:  DATA 6F,00
0220:  DATA 20,00
0222:  DATA 55,00
0224:  DATA 41,00
0226:  DATA 52,00
0228:  DATA 54,00
*
02D2:  MOVLB  1
02D4:  MOVF   x22,W
02D6:  MULWF  x24
02D8:  MOVFF  FF3,01
02DC:  MOVFF  FF4,00
02E0:  MULWF  x25
02E2:  MOVF   FF3,W
02E4:  ADDWF  00,F
02E6:  MOVF   x23,W
02E8:  MULWF  x24
02EA:  MOVF   FF3,W
02EC:  ADDWFC 00,W
02EE:  MOVWF  02
02F0:  MOVLB  0
02F2:  RETURN 0
*
1232:  MOVLW  8E
1234:  MOVWF  00
1236:  MOVFF  111,01
123A:  MOVFF  110,02
123E:  CLRF   03
1240:  MOVF   01,F
1242:  BNZ   1256
1244:  MOVFF  02,01
1248:  CLRF   02
124A:  MOVLW  08
124C:  SUBWF  00,F
124E:  MOVF   01,F
1250:  BNZ   1256
1252:  CLRF   00
1254:  BRA    1266
1256:  BCF    FD8.0
1258:  BTFSC  01.7
125A:  BRA    1264
125C:  RLCF   02,F
125E:  RLCF   01,F
1260:  DECF   00,F
1262:  BRA    1256
1264:  BCF    01.7
1266:  RETURN 0
1268:  MOVLB  1
126A:  MOVF   x14,W
126C:  BTFSC  FD8.2
126E:  BRA    13BA
1270:  MOVWF  x20
1272:  MOVF   x18,W
1274:  BTFSC  FD8.2
1276:  BRA    13BA
1278:  SUBWF  x20,F
127A:  BNC   1286
127C:  MOVLW  7F
127E:  ADDWF  x20,F
1280:  BTFSC  FD8.0
1282:  BRA    13BA
1284:  BRA    1292
1286:  MOVLW  81
1288:  SUBWF  x20,F
128A:  BTFSS  FD8.0
128C:  BRA    13BA
128E:  BTFSC  FD8.2
1290:  BRA    13BA
1292:  MOVFF  120,00
1296:  CLRF   01
1298:  CLRF   02
129A:  CLRF   03
129C:  CLRF   x1F
129E:  MOVFF  115,11E
12A2:  BSF    x1E.7
12A4:  MOVFF  116,11D
12A8:  MOVFF  117,11C
12AC:  MOVLW  19
12AE:  MOVWF  x20
12B0:  MOVF   x1B,W
12B2:  SUBWF  x1C,F
12B4:  BC    12D0
12B6:  MOVLW  01
12B8:  SUBWF  x1D,F
12BA:  BC    12D0
12BC:  SUBWF  x1E,F
12BE:  BC    12D0
12C0:  SUBWF  x1F,F
12C2:  BC    12D0
12C4:  INCF   x1F,F
12C6:  INCF   x1E,F
12C8:  INCF   x1D,F
12CA:  MOVF   x1B,W
12CC:  ADDWF  x1C,F
12CE:  BRA    1320
12D0:  MOVF   x1A,W
12D2:  SUBWF  x1D,F
12D4:  BC    12FA
12D6:  MOVLW  01
12D8:  SUBWF  x1E,F
12DA:  BC    12FA
12DC:  SUBWF  x1F,F
12DE:  BC    12FA
12E0:  INCF   x1F,F
12E2:  INCF   x1E,F
12E4:  MOVF   x1A,W
12E6:  ADDWF  x1D,F
12E8:  MOVF   x1B,W
12EA:  ADDWF  x1C,F
12EC:  BNC   1320
12EE:  INCF   x1D,F
12F0:  BNZ   1320
12F2:  INCF   x1E,F
12F4:  BNZ   1320
12F6:  INCF   x1F,F
12F8:  BRA    1320
12FA:  MOVF   x19,W
12FC:  IORLW  80
12FE:  SUBWF  x1E,F
1300:  BC    131E
1302:  MOVLW  01
1304:  SUBWF  x1F,F
1306:  BC    131E
1308:  INCF   x1F,F
130A:  MOVF   x19,W
130C:  IORLW  80
130E:  ADDWF  x1E,F
1310:  MOVF   x1A,W
1312:  ADDWF  x1D,F
1314:  BNC   12E8
1316:  INCF   x1E,F
1318:  BNZ   12E8
131A:  INCF   x1F,F
131C:  BRA    12E8
131E:  BSF    03.0
1320:  DECFSZ x20,F
1322:  BRA    1326
1324:  BRA    133C
1326:  BCF    FD8.0
1328:  RLCF   x1C,F
132A:  RLCF   x1D,F
132C:  RLCF   x1E,F
132E:  RLCF   x1F,F
1330:  BCF    FD8.0
1332:  RLCF   03,F
1334:  RLCF   02,F
1336:  RLCF   01,F
1338:  RLCF   x21,F
133A:  BRA    12B0
133C:  BTFSS  x21.0
133E:  BRA    134C
1340:  BCF    FD8.0
1342:  RRCF   01,F
1344:  RRCF   02,F
1346:  RRCF   03,F
1348:  RRCF   x21,F
134A:  BRA    1350
134C:  DECF   00,F
134E:  BZ    13BA
1350:  BTFSC  x21.7
1352:  BRA    1390
1354:  BCF    FD8.0
1356:  RLCF   x1C,F
1358:  RLCF   x1D,F
135A:  RLCF   x1E,F
135C:  RLCF   x1F,F
135E:  MOVF   x1B,W
1360:  SUBWF  x1C,F
1362:  BC    1372
1364:  MOVLW  01
1366:  SUBWF  x1D,F
1368:  BC    1372
136A:  SUBWF  x1E,F
136C:  BC    1372
136E:  SUBWF  x1F,F
1370:  BNC   13A6
1372:  MOVF   x1A,W
1374:  SUBWF  x1D,F
1376:  BC    1382
1378:  MOVLW  01
137A:  SUBWF  x1E,F
137C:  BC    1382
137E:  SUBWF  x1F,F
1380:  BNC   13A6
1382:  MOVF   x19,W
1384:  IORLW  80
1386:  SUBWF  x1E,F
1388:  BC    1390
138A:  MOVLW  01
138C:  SUBWF  x1F,F
138E:  BNC   13A6
1390:  INCF   03,F
1392:  BNZ   13A6
1394:  INCF   02,F
1396:  BNZ   13A6
1398:  INCF   01,F
139A:  BNZ   13A6
139C:  INCF   00,F
139E:  BZ    13BA
13A0:  RRCF   01,F
13A2:  RRCF   02,F
13A4:  RRCF   03,F
13A6:  MOVFF  115,120
13AA:  MOVF   x19,W
13AC:  XORWF  x20,F
13AE:  BTFSS  x20.7
13B0:  BRA    13B6
13B2:  BSF    01.7
13B4:  BRA    13C2
13B6:  BCF    01.7
13B8:  BRA    13C2
13BA:  CLRF   00
13BC:  CLRF   01
13BE:  CLRF   02
13C0:  CLRF   03
13C2:  MOVLB  0
13C4:  RETURN 0
*
1424:  DATA 69,6E
1426:  DATA 69,63
1428:  DATA 69,61
142A:  DATA 6E,64
142C:  DATA 6F,2E
142E:  DATA 2E,2E
1430:  DATA 00,00
1432:  DATA 0C,00
1434:  DATA 70,66
1436:  DATA 3D,25
1438:  DATA 2E,32
143A:  DATA 66,00
143C:  DATA 55,53
143E:  DATA 42,20
1440:  DATA 63,6F
1442:  DATA 6E,6E
1444:  DATA 20,20
1446:  DATA 20,20
1448:  DATA 20,20
144A:  DATA 20,20
144C:  DATA 20,00
144E:  DATA 0D,70
1450:  DATA 66,3D
1452:  DATA 25,2E
1454:  DATA 32,66
1456:  DATA 20,74
1458:  DATA 3D,25
145A:  DATA 2E,33
145C:  DATA 66,20
145E:  DATA 49,28
1460:  DATA 41,29
1462:  DATA 3D,25
1464:  DATA 2E,31
1466:  DATA 66,20
1468:  DATA 56,3D
146A:  DATA 20,25
146C:  DATA 2E,31
146E:  DATA 66,0A
1470:  DATA 20,00
1472:  DATA 70,66
1474:  DATA 3D,25
1476:  DATA 2E,32
1478:  DATA 66,0A
147A:  DATA 00,00
147C:  DATA 49,28
147E:  DATA 41,29
1480:  DATA 3D,25
1482:  DATA 2E,31
1484:  DATA 66,0A
1486:  DATA 00,00
1488:  DATA 49,28
148A:  DATA 41,29
148C:  DATA 3D,25
148E:  DATA 2E,31
1490:  DATA 66,0A
1492:  DATA 00,00
*
16DE:  TBLRD*+
16E0:  MOVF   FF5,F
16E2:  BZ    16FC
16E4:  MOVFF  FF6,D8
16E8:  MOVFF  FF7,D9
16EC:  MOVFF  FF5,E5
16F0:  RCALL  168E
16F2:  MOVFF  D8,FF6
16F6:  MOVFF  D9,FF7
16FA:  BRA    16DE
16FC:  RETURN 0
*
174C:  MOVF   xEA,W
174E:  BTFSC  FD8.2
1750:  BRA    1834
1752:  MOVWF  00
1754:  MOVF   xEE,W
1756:  BTFSC  FD8.2
1758:  BRA    1834
175A:  ADDWF  00,F
175C:  BNC   1766
175E:  MOVLW  81
1760:  ADDWF  00,F
1762:  BC    1834
1764:  BRA    176E
1766:  MOVLW  7F
1768:  SUBWF  00,F
176A:  BNC   1834
176C:  BZ    1834
176E:  MOVFF  EB,F2
1772:  MOVF   xEF,W
1774:  XORWF  xF2,F
1776:  BSF    xEB.7
1778:  BSF    xEF.7
177A:  MOVF   xED,W
177C:  MULWF  xF1
177E:  MOVFF  FF4,F4
1782:  MOVF   xEC,W
1784:  MULWF  xF0
1786:  MOVFF  FF4,03
178A:  MOVFF  FF3,F3
178E:  MULWF  xF1
1790:  MOVF   FF3,W
1792:  ADDWF  xF4,F
1794:  MOVF   FF4,W
1796:  ADDWFC xF3,F
1798:  MOVLW  00
179A:  ADDWFC 03,F
179C:  MOVF   xED,W
179E:  MULWF  xF0
17A0:  MOVF   FF3,W
17A2:  ADDWF  xF4,F
17A4:  MOVF   FF4,W
17A6:  ADDWFC xF3,F
17A8:  MOVLW  00
17AA:  CLRF   02
17AC:  ADDWFC 03,F
17AE:  ADDWFC 02,F
17B0:  MOVF   xEB,W
17B2:  MULWF  xF1
17B4:  MOVF   FF3,W
17B6:  ADDWF  xF3,F
17B8:  MOVF   FF4,W
17BA:  ADDWFC 03,F
17BC:  MOVLW  00
17BE:  ADDWFC 02,F
17C0:  MOVF   xEB,W
17C2:  MULWF  xF0
17C4:  MOVF   FF3,W
17C6:  ADDWF  03,F
17C8:  MOVF   FF4,W
17CA:  ADDWFC 02,F
17CC:  MOVLW  00
17CE:  CLRF   01
17D0:  ADDWFC 01,F
17D2:  MOVF   xED,W
17D4:  MULWF  xEF
17D6:  MOVF   FF3,W
17D8:  ADDWF  xF3,F
17DA:  MOVF   FF4,W
17DC:  ADDWFC 03,F
17DE:  MOVLW  00
17E0:  ADDWFC 02,F
17E2:  ADDWFC 01,F
17E4:  MOVF   xEC,W
17E6:  MULWF  xEF
17E8:  MOVF   FF3,W
17EA:  ADDWF  03,F
17EC:  MOVF   FF4,W
17EE:  ADDWFC 02,F
17F0:  MOVLW  00
17F2:  ADDWFC 01,F
17F4:  MOVF   xEB,W
17F6:  MULWF  xEF
17F8:  MOVF   FF3,W
17FA:  ADDWF  02,F
17FC:  MOVF   FF4,W
17FE:  ADDWFC 01,F
1800:  INCF   00,F
1802:  BTFSC  01.7
1804:  BRA    1810
1806:  RLCF   xF3,F
1808:  RLCF   03,F
180A:  RLCF   02,F
180C:  RLCF   01,F
180E:  DECF   00,F
1810:  MOVLW  00
1812:  BTFSS  xF3.7
1814:  BRA    182A
1816:  INCF   03,F
1818:  ADDWFC 02,F
181A:  ADDWFC 01,F
181C:  MOVF   01,W
181E:  BNZ   182A
1820:  MOVF   02,W
1822:  BNZ   182A
1824:  MOVF   03,W
1826:  BNZ   182A
1828:  INCF   00,F
182A:  BTFSC  xF2.7
182C:  BSF    01.7
182E:  BTFSS  xF2.7
1830:  BCF    01.7
1832:  BRA    183C
1834:  CLRF   00
1836:  CLRF   01
1838:  CLRF   02
183A:  CLRF   03
183C:  RETURN 0
183E:  MOVLW  8E
1840:  MOVWF  00
1842:  MOVF   xEA,W
1844:  SUBWF  00,F
1846:  MOVFF  EB,02
184A:  MOVFF  EC,01
184E:  BSF    02.7
1850:  MOVF   00,F
1852:  BZ    1866
1854:  BCF    FD8.0
1856:  MOVF   02,F
1858:  BNZ   185E
185A:  MOVF   01,F
185C:  BZ    1866
185E:  RRCF   02,F
1860:  RRCF   01,F
1862:  DECFSZ 00,F
1864:  BRA    1854
1866:  BTFSS  xEB.7
1868:  BRA    1874
186A:  COMF   01,F
186C:  COMF   02,F
186E:  INCF   01,F
1870:  BTFSC  FD8.2
1872:  INCF   02,F
1874:  RETURN 0
1876:  MOVLW  80
1878:  BTFSS  FD8.1
187A:  BRA    1880
187C:  MOVLB  1
187E:  XORWF  x01,F
1880:  MOVLB  1
1882:  CLRF   x06
1884:  CLRF   x07
1886:  MOVFF  FD,105
188A:  MOVF   x01,W
188C:  XORWF  x05,F
188E:  MOVLB  0
1890:  MOVF   xFC,W
1892:  BTFSC  FD8.2
1894:  BRA    1A52
1896:  MOVLB  1
1898:  MOVWF  x04
189A:  MOVWF  00
189C:  MOVF   x00,W
189E:  BTFSC  FD8.2
18A0:  BRA    1A66
18A2:  SUBWF  x04,F
18A4:  BTFSC  FD8.2
18A6:  BRA    19AE
18A8:  BNC   1922
18AA:  MOVFF  101,10A
18AE:  BSF    x0A.7
18B0:  MOVFF  102,109
18B4:  MOVFF  103,108
18B8:  CLRF   x07
18BA:  BCF    FD8.0
18BC:  RRCF   x0A,F
18BE:  RRCF   x09,F
18C0:  RRCF   x08,F
18C2:  RRCF   x07,F
18C4:  DECFSZ x04,F
18C6:  BRA    18B8
18C8:  BTFSS  x05.7
18CA:  BRA    18D2
18CC:  BSF    x06.0
18CE:  BRA    1A8E
18D0:  BCF    x06.0
18D2:  BCF    x04.0
18D4:  BSF    x06.4
18D6:  CLRF   FEA
18D8:  SETF   FE9
18DA:  BRA    1AB4
18DC:  BCF    x06.4
18DE:  BTFSC  x05.7
18E0:  BRA    18F6
18E2:  BTFSS  x04.0
18E4:  BRA    190C
18E6:  RRCF   x0A,F
18E8:  RRCF   x09,F
18EA:  RRCF   x08,F
18EC:  RRCF   x07,F
18EE:  INCF   00,F
18F0:  BTFSC  FD8.2
18F2:  BRA    1A84
18F4:  BRA    190C
18F6:  BTFSC  x0A.7
18F8:  BRA    1912
18FA:  BCF    FD8.0
18FC:  RLCF   x07,F
18FE:  RLCF   x08,F
1900:  RLCF   x09,F
1902:  RLCF   x0A,F
1904:  DECF   00,F
1906:  BTFSC  FD8.2
1908:  BRA    1A84
190A:  BRA    18F6
190C:  BSF    x06.6
190E:  BRA    19EA
1910:  BCF    x06.6
1912:  MOVFF  FD,105
1916:  BTFSS  x05.7
1918:  BRA    191E
191A:  BSF    x0A.7
191C:  BRA    1A76
191E:  BCF    x0A.7
1920:  BRA    1A76
1922:  MOVFF  100,104
1926:  MOVFF  100,00
192A:  MOVLB  0
192C:  MOVF   xFC,W
192E:  MOVLB  1
1930:  SUBWF  x04,F
1932:  MOVFF  FD,10A
1936:  BSF    x0A.7
1938:  MOVFF  FE,109
193C:  MOVFF  FF,108
1940:  CLRF   x07
1942:  BCF    FD8.0
1944:  RRCF   x0A,F
1946:  RRCF   x09,F
1948:  RRCF   x08,F
194A:  RRCF   x07,F
194C:  DECFSZ x04,F
194E:  BRA    1940
1950:  BTFSS  x05.7
1952:  BRA    195A
1954:  BSF    x06.1
1956:  BRA    1A8E
1958:  BCF    x06.1
195A:  BCF    x04.0
195C:  BSF    x06.5
195E:  MOVLW  01
1960:  MOVWF  FEA
1962:  MOVLW  03
1964:  MOVWF  FE9
1966:  BRA    1AB4
1968:  BCF    x06.5
196A:  BTFSC  x05.7
196C:  BRA    1982
196E:  BTFSS  x04.0
1970:  BRA    1998
1972:  RRCF   x0A,F
1974:  RRCF   x09,F
1976:  RRCF   x08,F
1978:  RRCF   x07,F
197A:  INCF   00,F
197C:  BTFSC  FD8.2
197E:  BRA    1A84
1980:  BRA    1998
1982:  BTFSC  x0A.7
1984:  BRA    199E
1986:  BCF    FD8.0
1988:  RLCF   x07,F
198A:  RLCF   x08,F
198C:  RLCF   x09,F
198E:  RLCF   x0A,F
1990:  DECF   00,F
1992:  BTFSC  FD8.2
1994:  BRA    1A84
1996:  BRA    1982
1998:  BSF    x06.7
199A:  BRA    19EA
199C:  BCF    x06.7
199E:  MOVFF  101,105
19A2:  BTFSS  x01.7
19A4:  BRA    19AA
19A6:  BSF    x0A.7
19A8:  BRA    1A76
19AA:  BCF    x0A.7
19AC:  BRA    1A76
19AE:  MOVFF  101,10A
19B2:  BSF    x0A.7
19B4:  MOVFF  102,109
19B8:  MOVFF  103,108
19BC:  BTFSS  x05.7
19BE:  BRA    19C8
19C0:  BCF    x0A.7
19C2:  BSF    x06.2
19C4:  BRA    1A8E
19C6:  BCF    x06.2
19C8:  CLRF   x07
19CA:  BCF    x04.0
19CC:  CLRF   FEA
19CE:  SETF   FE9
19D0:  BRA    1AB4
19D2:  BTFSC  x05.7
19D4:  BRA    1A0E
19D6:  MOVFF  FD,105
19DA:  BTFSS  x04.0
19DC:  BRA    19EA
19DE:  RRCF   x0A,F
19E0:  RRCF   x09,F
19E2:  RRCF   x08,F
19E4:  RRCF   x07,F
19E6:  INCF   00,F
19E8:  BZ    1A84
19EA:  BTFSS  x07.7
19EC:  BRA    1A04
19EE:  INCF   x08,F
19F0:  BNZ   1A04
19F2:  INCF   x09,F
19F4:  BNZ   1A04
19F6:  INCF   x0A,F
19F8:  BNZ   1A04
19FA:  RRCF   x0A,F
19FC:  RRCF   x09,F
19FE:  RRCF   x08,F
1A00:  INCF   00,F
1A02:  BZ    1A84
1A04:  BTFSC  x06.6
1A06:  BRA    1910
1A08:  BTFSC  x06.7
1A0A:  BRA    199C
1A0C:  BRA    1A46
1A0E:  MOVLW  80
1A10:  XORWF  x0A,F
1A12:  BTFSS  x0A.7
1A14:  BRA    1A1E
1A16:  BRA    1A8E
1A18:  MOVFF  101,105
1A1C:  BRA    1A32
1A1E:  MOVFF  FD,105
1A22:  MOVF   x0A,F
1A24:  BNZ   1A32
1A26:  MOVF   x09,F
1A28:  BNZ   1A32
1A2A:  MOVF   x08,F
1A2C:  BNZ   1A32
1A2E:  CLRF   00
1A30:  BRA    1A76
1A32:  BTFSC  x0A.7
1A34:  BRA    1A46
1A36:  BCF    FD8.0
1A38:  RLCF   x07,F
1A3A:  RLCF   x08,F
1A3C:  RLCF   x09,F
1A3E:  RLCF   x0A,F
1A40:  DECFSZ 00,F
1A42:  BRA    1A32
1A44:  BRA    1A84
1A46:  BTFSS  x05.7
1A48:  BRA    1A4E
1A4A:  BSF    x0A.7
1A4C:  BRA    1A76
1A4E:  BCF    x0A.7
1A50:  BRA    1A76
1A52:  MOVFF  100,00
1A56:  MOVFF  101,10A
1A5A:  MOVFF  102,109
1A5E:  MOVFF  103,108
1A62:  MOVLB  1
1A64:  BRA    1A76
1A66:  MOVFF  FC,00
1A6A:  MOVFF  FD,10A
1A6E:  MOVFF  FE,109
1A72:  MOVFF  FF,108
1A76:  MOVFF  10A,01
1A7A:  MOVFF  109,02
1A7E:  MOVFF  108,03
1A82:  BRA    1AEC
1A84:  CLRF   00
1A86:  CLRF   01
1A88:  CLRF   02
1A8A:  CLRF   03
1A8C:  BRA    1AEC
1A8E:  CLRF   x07
1A90:  COMF   x08,F
1A92:  COMF   x09,F
1A94:  COMF   x0A,F
1A96:  COMF   x07,F
1A98:  INCF   x07,F
1A9A:  BNZ   1AA6
1A9C:  INCF   x08,F
1A9E:  BNZ   1AA6
1AA0:  INCF   x09,F
1AA2:  BNZ   1AA6
1AA4:  INCF   x0A,F
1AA6:  BTFSC  x06.0
1AA8:  BRA    18D0
1AAA:  BTFSC  x06.1
1AAC:  BRA    1958
1AAE:  BTFSC  x06.2
1AB0:  BRA    19C6
1AB2:  BRA    1A18
1AB4:  MOVF   FEF,W
1AB6:  ADDWF  x08,F
1AB8:  BNC   1AC4
1ABA:  INCF   x09,F
1ABC:  BNZ   1AC4
1ABE:  INCF   x0A,F
1AC0:  BTFSC  FD8.2
1AC2:  BSF    x04.0
1AC4:  MOVF   FED,F
1AC6:  MOVF   FEF,W
1AC8:  ADDWF  x09,F
1ACA:  BNC   1AD2
1ACC:  INCF   x0A,F
1ACE:  BTFSC  FD8.2
1AD0:  BSF    x04.0
1AD2:  MOVF   FED,F
1AD4:  MOVF   FEF,W
1AD6:  BTFSC  FEF.7
1AD8:  BRA    1ADC
1ADA:  XORLW  80
1ADC:  ADDWF  x0A,F
1ADE:  BTFSC  FD8.0
1AE0:  BSF    x04.0
1AE2:  BTFSC  x06.4
1AE4:  BRA    18DC
1AE6:  BTFSC  x06.5
1AE8:  BRA    1968
1AEA:  BRA    19D2
1AEC:  MOVLB  0
1AEE:  RETURN 0
1AF0:  MOVFF  F9,100
1AF4:  MOVF   xFD,W
1AF6:  MOVLB  1
1AF8:  XORWF  x00,F
1AFA:  BTFSS  x00.7
1AFC:  BRA    1B0A
1AFE:  BCF    FD8.2
1B00:  BCF    FD8.0
1B02:  MOVLB  0
1B04:  BTFSC  xF9.7
1B06:  BSF    FD8.0
1B08:  BRA    1B94
1B0A:  MOVFF  F9,100
1B0E:  MOVFF  FC,101
1B12:  MOVLB  0
1B14:  MOVF   xF8,W
1B16:  MOVLB  1
1B18:  SUBWF  x01,F
1B1A:  BZ    1B2E
1B1C:  BTFSC  x00.7
1B1E:  BRA    1B24
1B20:  MOVLB  0
1B22:  BRA    1B94
1B24:  MOVF   FD8,W
1B26:  XORLW  01
1B28:  MOVWF  FD8
1B2A:  MOVLB  0
1B2C:  BRA    1B94
1B2E:  MOVFF  FD,101
1B32:  MOVLB  0
1B34:  MOVF   xF9,W
1B36:  MOVLB  1
1B38:  SUBWF  x01,F
1B3A:  BZ    1B4E
1B3C:  BTFSC  x00.7
1B3E:  BRA    1B44
1B40:  MOVLB  0
1B42:  BRA    1B94
1B44:  MOVF   FD8,W
1B46:  XORLW  01
1B48:  MOVWF  FD8
1B4A:  MOVLB  0
1B4C:  BRA    1B94
1B4E:  MOVFF  FE,101
1B52:  MOVLB  0
1B54:  MOVF   xFA,W
1B56:  MOVLB  1
1B58:  SUBWF  x01,F
1B5A:  BZ    1B6E
1B5C:  BTFSC  x00.7
1B5E:  BRA    1B64
1B60:  MOVLB  0
1B62:  BRA    1B94
1B64:  MOVF   FD8,W
1B66:  XORLW  01
1B68:  MOVWF  FD8
1B6A:  MOVLB  0
1B6C:  BRA    1B94
1B6E:  MOVFF  FF,101
1B72:  MOVLB  0
1B74:  MOVF   xFB,W
1B76:  MOVLB  1
1B78:  SUBWF  x01,F
1B7A:  BZ    1B90
1B7C:  BTFSC  x00.7
1B7E:  BRA    1B84
1B80:  MOVLB  0
1B82:  BRA    1B94
1B84:  MOVF   FD8,W
1B86:  XORLW  01
1B88:  MOVWF  FD8
1B8A:  MOVLB  0
1B8C:  BRA    1B94
1B8E:  MOVLB  1
1B90:  BCF    FD8.0
1B92:  MOVLB  0
1B94:  RETURN 0
*
2028:  TBLRD*+
202A:  MOVFF  FF6,D9
202E:  MOVFF  FF7,DA
2032:  MOVFF  FF5,E5
2036:  CALL   168E
203A:  MOVFF  D9,FF6
203E:  MOVFF  DA,FF7
2042:  DECFSZ xD8,F
2044:  BRA    2028
2046:  RETURN 0
2048:  MOVF   xE5,W
204A:  SUBLW  B6
204C:  MOVWF  xE5
204E:  CLRF   03
2050:  MOVFF  E6,E9
2054:  BSF    xE6.7
2056:  BCF    FD8.0
2058:  RRCF   xE6,F
205A:  RRCF   xE7,F
205C:  RRCF   xE8,F
205E:  RRCF   03,F
2060:  RRCF   02,F
2062:  RRCF   01,F
2064:  RRCF   00,F
2066:  DECFSZ xE5,F
2068:  BRA    2056
206A:  BTFSS  xE9.7
206C:  BRA    2084
206E:  COMF   00,F
2070:  COMF   01,F
2072:  COMF   02,F
2074:  COMF   03,F
2076:  INCF   00,F
2078:  BTFSC  FD8.2
207A:  INCF   01,F
207C:  BTFSC  FD8.2
207E:  INCF   02,F
2080:  BTFSC  FD8.2
2082:  INCF   03,F
2084:  RETURN 0
2086:  BTFSC  FD8.1
2088:  BRA    2090
208A:  CLRF   FEA
208C:  MOVLW  ED
208E:  MOVWF  FE9
2090:  CLRF   00
2092:  CLRF   01
2094:  CLRF   02
2096:  CLRF   03
2098:  CLRF   xED
209A:  CLRF   xEE
209C:  CLRF   xEF
209E:  CLRF   xF0
20A0:  MOVF   xEC,W
20A2:  IORWF  xEB,W
20A4:  IORWF  xEA,W
20A6:  IORWF  xE9,W
20A8:  BZ    2102
20AA:  MOVLW  20
20AC:  MOVWF  xF1
20AE:  BCF    FD8.0
20B0:  RLCF   xE5,F
20B2:  RLCF   xE6,F
20B4:  RLCF   xE7,F
20B6:  RLCF   xE8,F
20B8:  RLCF   xED,F
20BA:  RLCF   xEE,F
20BC:  RLCF   xEF,F
20BE:  RLCF   xF0,F
20C0:  MOVF   xEC,W
20C2:  SUBWF  xF0,W
20C4:  BNZ   20D6
20C6:  MOVF   xEB,W
20C8:  SUBWF  xEF,W
20CA:  BNZ   20D6
20CC:  MOVF   xEA,W
20CE:  SUBWF  xEE,W
20D0:  BNZ   20D6
20D2:  MOVF   xE9,W
20D4:  SUBWF  xED,W
20D6:  BNC   20F6
20D8:  MOVF   xE9,W
20DA:  SUBWF  xED,F
20DC:  MOVF   xEA,W
20DE:  BTFSS  FD8.0
20E0:  INCFSZ xEA,W
20E2:  SUBWF  xEE,F
20E4:  MOVF   xEB,W
20E6:  BTFSS  FD8.0
20E8:  INCFSZ xEB,W
20EA:  SUBWF  xEF,F
20EC:  MOVF   xEC,W
20EE:  BTFSS  FD8.0
20F0:  INCFSZ xEC,W
20F2:  SUBWF  xF0,F
20F4:  BSF    FD8.0
20F6:  RLCF   00,F
20F8:  RLCF   01,F
20FA:  RLCF   02,F
20FC:  RLCF   03,F
20FE:  DECFSZ xF1,F
2100:  BRA    20AE
2102:  MOVFF  ED,FEF
2106:  MOVFF  EE,FEC
210A:  MOVFF  EF,FEC
210E:  MOVFF  F0,FEC
2112:  RETURN 0
2114:  MOVF   FE9,W
2116:  MOVWF  xDD
2118:  MOVF   xDC,W
211A:  MOVWF  xDF
211C:  BZ    2152
211E:  MOVFF  DB,ED
2122:  MOVFF  DA,EC
2126:  MOVFF  D9,EB
212A:  MOVFF  D8,EA
212E:  CLRF   xF1
2130:  CLRF   xF0
2132:  MOVLW  20
2134:  MOVWF  xEF
2136:  MOVLW  82
2138:  MOVWF  xEE
213A:  CALL   174C
213E:  MOVFF  03,DB
2142:  MOVFF  02,DA
2146:  MOVFF  01,D9
214A:  MOVFF  00,D8
214E:  DECFSZ xDF,F
2150:  BRA    211E
2152:  MOVFF  DB,E8
2156:  MOVFF  DA,E7
215A:  MOVFF  D9,E6
215E:  MOVFF  D8,E5
2162:  RCALL  2048
2164:  MOVFF  03,DB
2168:  MOVFF  02,DA
216C:  MOVFF  01,D9
2170:  MOVFF  00,D8
2174:  BTFSS  xDB.7
2176:  BRA    2192
2178:  DECF   xDD,F
217A:  BSF    xDD.5
217C:  COMF   xD8,F
217E:  COMF   xD9,F
2180:  COMF   xDA,F
2182:  COMF   xDB,F
2184:  INCF   xD8,F
2186:  BTFSC  FD8.2
2188:  INCF   xD9,F
218A:  BTFSC  FD8.2
218C:  INCF   xDA,F
218E:  BTFSC  FD8.2
2190:  INCF   xDB,F
2192:  MOVLW  3B
2194:  MOVWF  xE4
2196:  MOVLW  9A
2198:  MOVWF  xE3
219A:  MOVLW  CA
219C:  MOVWF  xE2
219E:  CLRF   xE1
21A0:  MOVLW  0A
21A2:  MOVWF  xDF
21A4:  MOVF   xDC,W
21A6:  BTFSC  FD8.2
21A8:  INCF   xDD,F
21AA:  BSF    FD8.1
21AC:  CLRF   FEA
21AE:  MOVLW  D8
21B0:  MOVWF  FE9
21B2:  MOVFF  DB,E8
21B6:  MOVFF  DA,E7
21BA:  MOVFF  D9,E6
21BE:  MOVFF  D8,E5
21C2:  MOVFF  E4,EC
21C6:  MOVFF  E3,EB
21CA:  MOVFF  E2,EA
21CE:  MOVFF  E1,E9
21D2:  RCALL  2086
21D4:  MOVF   01,W
21D6:  MOVF   00,F
21D8:  BNZ   21F8
21DA:  INCF   xDC,W
21DC:  SUBWF  xDF,W
21DE:  BZ    21F8
21E0:  MOVF   xDD,W
21E2:  BZ    21FC
21E4:  ANDLW  0F
21E6:  SUBWF  xDF,W
21E8:  BZ    21EC
21EA:  BC    2262
21EC:  BTFSC  xDD.7
21EE:  BRA    2262
21F0:  BTFSC  xDD.6
21F2:  BRA    21FC
21F4:  MOVLW  20
21F6:  BRA    2258
21F8:  MOVLW  20
21FA:  ANDWF  xDD,F
21FC:  BTFSS  xDD.5
21FE:  BRA    221A
2200:  BCF    xDD.5
2202:  MOVF   xDC,W
2204:  BTFSS  FD8.2
2206:  DECF   xDD,F
2208:  MOVF   00,W
220A:  MOVWF  xDD
220C:  MOVLW  2D
220E:  MOVWF  xE5
2210:  CALL   168E
2214:  MOVF   xDD,W
2216:  MOVWF  00
2218:  CLRF   xDD
221A:  MOVF   xDC,W
221C:  SUBWF  xDF,W
221E:  BNZ   2236
2220:  MOVF   00,W
2222:  MOVWF  xDD
2224:  MOVLW  2E
2226:  MOVWF  xE5
2228:  CALL   168E
222C:  MOVF   xDD,W
222E:  MOVWF  00
2230:  MOVLW  20
2232:  ANDWF  xDD,F
2234:  MOVLW  00
2236:  MOVLW  30
2238:  BTFSS  xDD.5
223A:  BRA    2258
223C:  BCF    xDD.5
223E:  MOVF   xDC,W
2240:  BTFSS  FD8.2
2242:  DECF   xDD,F
2244:  MOVF   00,W
2246:  MOVWF  xDD
2248:  MOVLW  2D
224A:  MOVWF  xE5
224C:  CALL   168E
2250:  MOVF   xDD,W
2252:  MOVWF  00
2254:  CLRF   xDD
2256:  MOVLW  30
2258:  ADDWF  00,F
225A:  MOVFF  00,E5
225E:  CALL   168E
2262:  BCF    FD8.1
2264:  MOVFF  E4,E8
2268:  MOVFF  E3,E7
226C:  MOVFF  E2,E6
2270:  MOVFF  E1,E5
2274:  CLRF   xEC
2276:  CLRF   xEB
2278:  CLRF   xEA
227A:  MOVLW  0A
227C:  MOVWF  xE9
227E:  RCALL  2086
2280:  MOVFF  03,E4
2284:  MOVFF  02,E3
2288:  MOVFF  01,E2
228C:  MOVFF  00,E1
2290:  DECFSZ xDF,F
2292:  BRA    21AA
2294:  RETURN 0
*
22F2:  TBLRD*+
22F4:  MOVFF  FF6,D9
22F8:  MOVFF  FF7,DA
22FC:  MOVFF  FF5,E5
2300:  RCALL  22E0
2302:  MOVFF  D9,FF6
2306:  MOVFF  DA,FF7
230A:  DECFSZ xD8,F
230C:  BRA    22F2
230E:  RETURN 0
2310:  MOVF   FE9,W
2312:  MOVWF  xDD
2314:  MOVF   xDC,W
2316:  MOVWF  xDF
2318:  BZ    234E
231A:  MOVFF  DB,ED
231E:  MOVFF  DA,EC
2322:  MOVFF  D9,EB
2326:  MOVFF  D8,EA
232A:  CLRF   xF1
232C:  CLRF   xF0
232E:  MOVLW  20
2330:  MOVWF  xEF
2332:  MOVLW  82
2334:  MOVWF  xEE
2336:  CALL   174C
233A:  MOVFF  03,DB
233E:  MOVFF  02,DA
2342:  MOVFF  01,D9
2346:  MOVFF  00,D8
234A:  DECFSZ xDF,F
234C:  BRA    231A
234E:  MOVFF  DB,E8
2352:  MOVFF  DA,E7
2356:  MOVFF  D9,E6
235A:  MOVFF  D8,E5
235E:  RCALL  2048
2360:  MOVFF  03,DB
2364:  MOVFF  02,DA
2368:  MOVFF  01,D9
236C:  MOVFF  00,D8
2370:  BTFSS  xDB.7
2372:  BRA    238E
2374:  DECF   xDD,F
2376:  BSF    xDD.5
2378:  COMF   xD8,F
237A:  COMF   xD9,F
237C:  COMF   xDA,F
237E:  COMF   xDB,F
2380:  INCF   xD8,F
2382:  BTFSC  FD8.2
2384:  INCF   xD9,F
2386:  BTFSC  FD8.2
2388:  INCF   xDA,F
238A:  BTFSC  FD8.2
238C:  INCF   xDB,F
238E:  MOVLW  3B
2390:  MOVWF  xE4
2392:  MOVLW  9A
2394:  MOVWF  xE3
2396:  MOVLW  CA
2398:  MOVWF  xE2
239A:  CLRF   xE1
239C:  MOVLW  0A
239E:  MOVWF  xDF
23A0:  MOVF   xDC,W
23A2:  BTFSC  FD8.2
23A4:  INCF   xDD,F
23A6:  BSF    FD8.1
23A8:  CLRF   FEA
23AA:  MOVLW  D8
23AC:  MOVWF  FE9
23AE:  MOVFF  DB,E8
23B2:  MOVFF  DA,E7
23B6:  MOVFF  D9,E6
23BA:  MOVFF  D8,E5
23BE:  MOVFF  E4,EC
23C2:  MOVFF  E3,EB
23C6:  MOVFF  E2,EA
23CA:  MOVFF  E1,E9
23CE:  RCALL  2086
23D0:  MOVF   01,W
23D2:  MOVF   00,F
23D4:  BNZ   23F4
23D6:  INCF   xDC,W
23D8:  SUBWF  xDF,W
23DA:  BZ    23F4
23DC:  MOVF   xDD,W
23DE:  BZ    23F8
23E0:  ANDLW  0F
23E2:  SUBWF  xDF,W
23E4:  BZ    23E8
23E6:  BC    2456
23E8:  BTFSC  xDD.7
23EA:  BRA    2456
23EC:  BTFSC  xDD.6
23EE:  BRA    23F8
23F0:  MOVLW  20
23F2:  BRA    244E
23F4:  MOVLW  20
23F6:  ANDWF  xDD,F
23F8:  BTFSS  xDD.5
23FA:  BRA    2414
23FC:  BCF    xDD.5
23FE:  MOVF   xDC,W
2400:  BTFSS  FD8.2
2402:  DECF   xDD,F
2404:  MOVF   00,W
2406:  MOVWF  xDD
2408:  MOVLW  2D
240A:  MOVWF  xE5
240C:  RCALL  22E0
240E:  MOVF   xDD,W
2410:  MOVWF  00
2412:  CLRF   xDD
2414:  MOVF   xDC,W
2416:  SUBWF  xDF,W
2418:  BNZ   242E
241A:  MOVF   00,W
241C:  MOVWF  xDD
241E:  MOVLW  2E
2420:  MOVWF  xE5
2422:  RCALL  22E0
2424:  MOVF   xDD,W
2426:  MOVWF  00
2428:  MOVLW  20
242A:  ANDWF  xDD,F
242C:  MOVLW  00
242E:  MOVLW  30
2430:  BTFSS  xDD.5
2432:  BRA    244E
2434:  BCF    xDD.5
2436:  MOVF   xDC,W
2438:  BTFSS  FD8.2
243A:  DECF   xDD,F
243C:  MOVF   00,W
243E:  MOVWF  xDD
2440:  MOVLW  2D
2442:  MOVWF  xE5
2444:  RCALL  22E0
2446:  MOVF   xDD,W
2448:  MOVWF  00
244A:  CLRF   xDD
244C:  MOVLW  30
244E:  ADDWF  00,F
2450:  MOVFF  00,E5
2454:  RCALL  22E0
2456:  BCF    FD8.1
2458:  MOVFF  E4,E8
245C:  MOVFF  E3,E7
2460:  MOVFF  E2,E6
2464:  MOVFF  E1,E5
2468:  CLRF   xEC
246A:  CLRF   xEB
246C:  CLRF   xEA
246E:  MOVLW  0A
2470:  MOVWF  xE9
2472:  RCALL  2086
2474:  MOVFF  03,E4
2478:  MOVFF  02,E3
247C:  MOVFF  01,E2
2480:  MOVFF  00,E1
2484:  DECFSZ xDF,F
2486:  BRA    23A6
2488:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses PLL1,CPUDIV3,HSPLL,PUT,NOLVP,NOPROTECT,NODEBUG,NOWDT,NOLPT1OSC,USBDIV 
.................... #device adc=10 
.................... #use delay(clock=32MHz) 
*
1494:  CLRF   FEA
1496:  MOVLW  E6
1498:  MOVWF  FE9
149A:  MOVF   FEF,W
149C:  BZ    14B8
149E:  MOVLW  0A
14A0:  MOVWF  01
14A2:  CLRF   00
14A4:  DECFSZ 00,F
14A6:  BRA    14A4
14A8:  DECFSZ 01,F
14AA:  BRA    14A2
14AC:  MOVLW  5F
14AE:  MOVWF  00
14B0:  DECFSZ 00,F
14B2:  BRA    14B0
14B4:  DECFSZ FEF,F
14B6:  BRA    149E
14B8:  RETURN 0
.................... #define compensar 0.70 
.................... #define USB_CON_SENSE PIN_D0 
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'ptr' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    //// 
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'len' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns the number of bytes available      //// 
.................... ////     in the TX buffer for storing characters.  If this returns   //// 
.................... ////     0 then the buffer is full and waiting for the host (PC)     //// 
.................... ////     to read the buffer.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  //// 
.................... //// be called when there is incoming CDC (virtual com port) data.   //// 
.................... //// This is useful if you want to update legacy RS232 code that     //// 
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    //// 
.................... //// However, see the INTERRUPT LIMITATIONS section below.           //// 
.................... ////                                                                 //// 
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    //// 
.................... ////  to flush the data as soon as possible.  However at times       //// 
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   //// 
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         //// 
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     //// 
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       //// 
.................... ////  also attempt to flush the packet on each call to usb_task().   //// 
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     //// 
.................... ////  if you have a main loop that periodically calls usb_task().    //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// BUFFER SIZES                                                    //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     //// 
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        //// 
.................... ////  Full speed devices limit this value to be 64.  To increase     //// 
.................... ////  the size of the local PIC buffer you can also define           //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        //// 
.................... ////  defined then the total PIC->PC buffer size would be            //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  //// 
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      //// 
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      //// 
.................... ////  then this option isn't used.                                   //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// INTERRUPT LIMITATIONS                                           //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// This section is only relevant if you are using USB interrupts   //// 
.................... ////  and not the USB_ISR_POLLING option.                            //// 
.................... ////                                                                 //// 
.................... //// USB handling is complex, often requiring several packet         //// 
.................... ////  transmissions to accomplish transfer of one block of data.     //// 
.................... ////  Most of this processing is done in the USB ISR.  Because       //// 
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the //// 
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   //// 
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  //// 
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  //// 
.................... ////  overflow the TX buffer than data will be lost.                 //// 
.................... ////                                                                 //// 
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB //// 
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      //// 
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           //// 
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    //// 
.................... ////                                                                 //// 
.................... //// ex_usb_serial3.c shows an example of working around these       //// 
.................... ////  ISR limitations.  Failure to follow these limitations can      //// 
.................... ////  cause the PIC to lockup.  These limtations only need to be     //// 
.................... ////  followed in the conditions listed above (writing code in the   //// 
.................... ////  ISR or interrupts are disabled).                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// May 31st, 2013:                                                 //// 
.................... ////  usb_cdc_putready() now returns the number of bytes available.  //// 
.................... ////                                                                 //// 
.................... //// May 23rd, 2013:                                                 //// 
.................... ////  Added usb_cdc_putd().                                          //// 
.................... ////                                                                 //// 
.................... //// February 18th, 2013:                                            //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 //// 
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_tx_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCM__) 
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c 
....................    #elif defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////     PIC18FxxK50                                                 //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==0 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x000b 
....................    //#define  USB_CONFIG_PID       0x0033    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x2405 
....................    //#define  USB_CONFIG_VID       0x0461    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          32, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          't',0, 
....................          'o',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'A',0, 
....................          'R',0, 
....................          'T',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F24K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF24K50")) 
....................  #define __USB_45K50__ 
....................  #define USB_TOTAL_RAM_SPACE  1024 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ //backwards compatability 
....................  #define __USB_14K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_14K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML = getenv("SFR:UFRML") 
....................    #byte UFRMH = getenv("SFR:UFRMH") 
....................    #byte UIR = getenv("SFR:UIR") 
....................    #byte UIE = getenv("SFR:UIE") 
....................    #byte UEIR = getenv("SFR:UEIR") 
....................    #byte UEIE = getenv("SFR:UEIE") 
....................    #byte U1STAT = getenv("SFR:USTAT") 
....................    #byte UCON = getenv("SFR:UCON") 
....................    #byte UADDR = getenv("SFR:UADDR") 
....................    #byte UCFG = getenv("SFR:UCFG") 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #if defined(UEP0_LOC) 
.................... #locate g_UEP=UEP0_LOC 
.................... #else 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #endif 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_14K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0D22:  CLRF   03
0D24:  MOVLB  1
0D26:  MOVF   x21,W
0D28:  ADDLW  70
0D2A:  MOVWF  FE9
0D2C:  MOVLW  0F
0D2E:  ADDWFC 03,W
0D30:  MOVWF  FEA
0D32:  MOVF   FEF,F
0D34:  BZ    0D6C
0D36:  CLRF   x23
0D38:  MOVFF  121,122
0D3C:  CLRF   x25
0D3E:  MOVLW  08
0D40:  MOVWF  x24
0D42:  MOVLB  0
0D44:  CALL   02D2
0D48:  MOVFF  02,123
0D4C:  MOVFF  01,122
0D50:  MOVLW  04
0D52:  MOVLB  1
0D54:  ADDWF  x22,F
0D56:  MOVLW  00
0D58:  ADDWFC x23,F
0D5A:  MOVFF  122,FE9
0D5E:  MOVLW  04
0D60:  ADDWF  x23,W
0D62:  MOVWF  FEA
0D64:  MOVFF  FEF,124
0D68:  BTFSS  x24.7
0D6A:  BRA    0D70
0D6C:  MOVLW  00
0D6E:  BRA    0D72
0D70:  MOVLW  01
0D72:  MOVWF  01
0D74:  MOVLB  0
0D76:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
....................    UIE = 0;   //disable USB interrupts 
....................    UCFG = __UCFG_VAL_DISABLED__; 
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_14K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #elif !defined(USB_PIC_NO_USB_GPIO) 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
*
16FE:  CLRF   16
1700:  BTFSC  FF2.7
1702:  BSF    16.7
1704:  BCF    FF2.7
.................... { 
....................    usb_token_reset(); 
1706:  CALL   03FE
170A:  BTFSC  16.7
170C:  BSF    FF2.7
....................    UCON = 0; 
170E:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1710:  MOVLW  14
1712:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
1714:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1716:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1718:  MOVLW  01
171A:  MOVWF  22
171C:  GOTO   1726 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
1720:  BTFSC  F6D.3
1722:  BRA    1726
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1724:  BRA    16FE
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1726:  DECFSZ 22,W
1728:  BRA    1740
172A:  BTFSC  F6D.5
172C:  BRA    1740
....................    { 
....................       UIR=0; 
172E:  CLRF   F68
....................       UIE=0; 
1730:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
1732:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1734:  MOVLW  C0
1736:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1738:  MOVLW  11
173A:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
173C:  MOVLW  02
173E:  MOVWF  22
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
1740:  GOTO   318C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0D78:  MOVFF  11C,121
0D7C:  RCALL  0D22
0D7E:  MOVF   01,F
0D80:  BTFSC  FD8.2
0D82:  BRA    0E92
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0D84:  MOVLB  1
0D86:  CLRF   x23
0D88:  MOVFF  11C,122
0D8C:  CLRF   x25
0D8E:  MOVLW  08
0D90:  MOVWF  x24
0D92:  MOVLB  0
0D94:  CALL   02D2
0D98:  MOVFF  02,122
0D9C:  MOVFF  01,121
0DA0:  MOVLW  04
0DA2:  MOVLB  1
0DA4:  ADDWF  x21,F
0DA6:  MOVLW  00
0DA8:  ADDWFC x22,F
0DAA:  MOVLW  01
0DAC:  ADDWF  x21,W
0DAE:  MOVWF  01
0DB0:  MOVLW  00
0DB2:  ADDWFC x22,W
0DB4:  MOVWF  03
0DB6:  MOVFF  01,FE9
0DBA:  MOVLW  04
0DBC:  ADDWF  03,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  11D,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0DC4:  MOVF   x1F,W
0DC6:  SUBLW  02
0DC8:  BNZ   0E0A
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0DCA:  CLRF   x23
0DCC:  MOVFF  11C,122
0DD0:  CLRF   x25
0DD2:  MOVLW  08
0DD4:  MOVWF  x24
0DD6:  MOVLB  0
0DD8:  CALL   02D2
0DDC:  MOVFF  02,122
0DE0:  MOVFF  01,121
0DE4:  MOVLW  04
0DE6:  MOVLB  1
0DE8:  ADDWF  x21,F
0DEA:  MOVLW  00
0DEC:  ADDWFC x22,F
0DEE:  MOVFF  121,FE9
0DF2:  MOVLW  04
0DF4:  ADDWF  x22,W
0DF6:  MOVWF  FEA
0DF8:  MOVFF  FEF,120
....................          if (bit_test(i,6)) 
0DFC:  BTFSS  x20.6
0DFE:  BRA    0E04
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0E00:  CLRF   x1F
0E02:  BRA    0E08
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0E04:  MOVLW  01
0E06:  MOVWF  x1F
....................       } 
0E08:  BRA    0E3E
....................       else if (tgl == USB_DTS_USERX)  
0E0A:  MOVF   x1F,W
0E0C:  SUBLW  04
0E0E:  BNZ   0E3E
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0E10:  CLRF   x23
0E12:  MOVFF  11C,122
0E16:  CLRF   x25
0E18:  MOVLW  08
0E1A:  MOVWF  x24
0E1C:  MOVLB  0
0E1E:  CALL   02D2
0E22:  MOVLB  1
0E24:  MOVFF  01,FE9
0E28:  MOVLW  04
0E2A:  ADDWF  02,W
0E2C:  MOVWF  FEA
0E2E:  MOVFF  FEF,120
....................          if (bit_test(i,6)) 
0E32:  BTFSS  x20.6
0E34:  BRA    0E3C
....................             tgl = USB_DTS_DATA1; 
0E36:  MOVLW  01
0E38:  MOVWF  x1F
0E3A:  BRA    0E3E
....................          else 
....................             tgl = USB_DTS_DATA0; 
0E3C:  CLRF   x1F
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0E3E:  DECFSZ x1F,W
0E40:  BRA    0E48
....................          i=0xC8;  //DATA1, UOWN 
0E42:  MOVLW  C8
0E44:  MOVWF  x20
0E46:  BRA    0E4C
....................       else //if (tgl == USB_DTS_DATA0)  
....................          i=0x88; //DATA0, UOWN 
0E48:  MOVLW  88
0E4A:  MOVWF  x20
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0E4C:  BTFSS  x1E.0
0E4E:  BRA    0E52
0E50:  BSF    x20.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0E52:  BTFSS  x1E.1
0E54:  BRA    0E58
0E56:  BSF    x20.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0E58:  CLRF   x23
0E5A:  MOVFF  11C,122
0E5E:  CLRF   x25
0E60:  MOVLW  08
0E62:  MOVWF  x24
0E64:  MOVLB  0
0E66:  CALL   02D2
0E6A:  MOVFF  02,122
0E6E:  MOVFF  01,121
0E72:  MOVLW  04
0E74:  MOVLB  1
0E76:  ADDWF  x21,F
0E78:  MOVLW  00
0E7A:  ADDWFC x22,F
0E7C:  MOVFF  121,FE9
0E80:  MOVLW  04
0E82:  ADDWF  x22,W
0E84:  MOVWF  FEA
0E86:  MOVFF  120,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0E8A:  MOVLW  01
0E8C:  MOVWF  01
0E8E:  BRA    0E98
....................    } 
0E90:  MOVLB  0
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0E92:  MOVLW  00
0E94:  MOVWF  01
0E96:  MOVLB  1
0E98:  MOVLB  0
0E9A:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
0FB6:  MOVFF  114,121
0FBA:  RCALL  0D22
0FBC:  MOVF   01,F
0FBE:  BZ    104E
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0FC0:  MOVLB  1
0FC2:  CLRF   x23
0FC4:  MOVFF  114,122
0FC8:  CLRF   x25
0FCA:  MOVLW  08
0FCC:  MOVWF  x24
0FCE:  MOVLB  0
0FD0:  CALL   02D2
0FD4:  MOVFF  02,11D
0FD8:  MOVFF  01,11C
0FDC:  MOVLW  04
0FDE:  MOVLB  1
0FE0:  ADDWF  x1C,F
0FE2:  MOVLW  00
0FE4:  ADDWFC x1D,F
0FE6:  MOVLW  02
0FE8:  ADDWF  x1C,W
0FEA:  MOVWF  01
0FEC:  MOVLW  00
0FEE:  ADDWFC x1D,W
0FF0:  MOVWF  03
0FF2:  MOVFF  01,FE9
0FF6:  MOVLW  04
0FF8:  ADDWF  03,W
0FFA:  MOVWF  FEA
0FFC:  MOVFF  FEC,11B
1000:  MOVF   FED,F
1002:  MOVFF  FEF,11A
....................       memcpy(buff_add, ptr, len);      
1006:  MOVFF  11B,FEA
100A:  MOVFF  11A,FE9
100E:  MOVFF  116,FE2
1012:  MOVFF  115,FE1
1016:  MOVFF  118,02
101A:  MOVFF  117,01
101E:  MOVF   01,F
1020:  BZ    1026
1022:  INCF   02,F
1024:  BRA    102A
1026:  MOVF   02,F
1028:  BZ    1036
102A:  MOVFF  FE6,FEE
102E:  DECFSZ 01,F
1030:  BRA    102A
1032:  DECFSZ 02,F
1034:  BRA    102A
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
1036:  MOVFF  114,11C
103A:  MOVFF  118,11E
103E:  MOVFF  117,11D
1042:  MOVFF  119,11F
1046:  MOVLB  0
1048:  RCALL  0D78
104A:  MOVF   01,W
104C:  BRA    1052
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
104E:  MOVLW  00
1050:  MOVWF  01
1052:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0C18:  MOVLB  1
0C1A:  CLRF   x23
0C1C:  MOVFF  114,122
0C20:  CLRF   x25
0C22:  MOVLW  08
0C24:  MOVWF  x24
0C26:  MOVLB  0
0C28:  CALL   02D2
0C2C:  MOVLB  1
0C2E:  MOVFF  01,FE9
0C32:  MOVLW  04
0C34:  ADDWF  02,W
0C36:  MOVWF  FEA
0C38:  MOVFF  FEF,116
....................    if (tgl == USB_DTS_TOGGLE)  
0C3C:  MOVF   x15,W
0C3E:  SUBLW  02
0C40:  BNZ   0C4E
....................    { 
....................       if (bit_test(i,6)) 
0C42:  BTFSS  x16.6
0C44:  BRA    0C4A
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0C46:  CLRF   x15
0C48:  BRA    0C4E
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0C4A:  MOVLW  01
0C4C:  MOVWF  x15
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0C4E:  MOVF   x15,W
0C50:  SUBLW  03
0C52:  BNZ   0C8C
....................    { 
....................       i = 0x84; 
0C54:  MOVLW  84
0C56:  MOVWF  x16
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0C58:  CLRF   x23
0C5A:  MOVFF  114,122
0C5E:  CLRF   x25
0C60:  MOVLW  08
0C62:  MOVWF  x24
0C64:  MOVLB  0
0C66:  CALL   02D2
0C6A:  MOVFF  02,11A
0C6E:  MOVFF  01,119
0C72:  MOVLW  04
0C74:  MOVLB  1
0C76:  ADDWF  x19,F
0C78:  MOVLW  00
0C7A:  ADDWFC x1A,F
0C7C:  MOVFF  119,FE9
0C80:  MOVLW  04
0C82:  ADDWF  x1A,W
0C84:  MOVWF  FEA
0C86:  MOVLW  84
0C88:  MOVWF  FEF
....................    } 
0C8A:  BRA    0C9A
....................    else if (tgl == USB_DTS_DATA1) 
0C8C:  DECFSZ x15,W
0C8E:  BRA    0C96
....................       i = 0xC8;  //DATA1, UOWN 
0C90:  MOVLW  C8
0C92:  MOVWF  x16
0C94:  BRA    0C9A
....................    else //if (tgl == USB_DTS_DATA0)  
....................       i = 0x88; //DATA0, UOWN 
0C96:  MOVLW  88
0C98:  MOVWF  x16
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0C9A:  BCF    FD8.0
0C9C:  RLCF   x14,W
0C9E:  CLRF   03
0CA0:  MOVFF  FF2,119
0CA4:  BCF    FF2.7
0CA6:  MOVLB  0
0CA8:  CALL   011E
0CAC:  TBLRD*+
0CAE:  MOVFF  FF5,03
0CB2:  MOVLB  1
0CB4:  BTFSC  x19.7
0CB6:  BSF    FF2.7
0CB8:  MOVWF  x17
0CBA:  MOVFF  03,118
....................    EP_BDxCNT_O(endpoint) = len; 
0CBE:  CLRF   x23
0CC0:  MOVFF  114,122
0CC4:  CLRF   x25
0CC6:  MOVLW  08
0CC8:  MOVWF  x24
0CCA:  MOVLB  0
0CCC:  CALL   02D2
0CD0:  MOVFF  01,119
0CD4:  MOVLW  01
0CD6:  MOVLB  1
0CD8:  ADDWF  01,W
0CDA:  MOVWF  01
0CDC:  MOVLW  00
0CDE:  ADDWFC 02,W
0CE0:  MOVWF  03
0CE2:  MOVFF  01,FE9
0CE6:  MOVLW  04
0CE8:  ADDWF  03,W
0CEA:  MOVWF  FEA
0CEC:  MOVFF  117,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0CF0:  BTFSS  x18.0
0CF2:  BRA    0CF6
0CF4:  BSF    x16.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0CF6:  BTFSS  x18.1
0CF8:  BRA    0CFC
0CFA:  BSF    x16.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0CFC:  CLRF   x23
0CFE:  MOVFF  114,122
0D02:  CLRF   x25
0D04:  MOVLW  08
0D06:  MOVWF  x24
0D08:  MOVLB  0
0D0A:  CALL   02D2
0D0E:  MOVLB  1
0D10:  MOVFF  01,FE9
0D14:  MOVLW  04
0D16:  ADDWF  02,W
0D18:  MOVWF  FEA
0D1A:  MOVFF  116,FEF
0D1E:  MOVLB  0
0D20:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
0EFE:  MOVLB  1
0F00:  CLRF   x23
0F02:  MOVFF  114,122
0F06:  CLRF   x25
0F08:  MOVLW  08
0F0A:  MOVWF  x24
0F0C:  MOVLB  0
0F0E:  CALL   02D2
0F12:  MOVFF  02,116
0F16:  MOVFF  01,115
0F1A:  MOVLW  01
0F1C:  MOVLB  1
0F1E:  ADDWF  01,W
0F20:  MOVWF  01
0F22:  MOVLW  00
0F24:  ADDWFC 02,W
0F26:  MOVWF  03
0F28:  MOVFF  01,FE9
0F2C:  MOVLW  04
0F2E:  ADDWF  03,W
0F30:  MOVWF  FEA
0F32:  CLRF   03
0F34:  MOVFF  FEF,01
0F38:  MOVFF  03,02
0F3C:  MOVLB  0
0F3E:  GOTO   0F62 (RETURN)
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
09EA:  MOVLB  1
09EC:  BCF    x14.0
09EE:  BTFSC  x13.7
09F0:  BSF    x14.0
....................    endpoint &= 0x7F; 
09F2:  BCF    x13.7
....................     
....................    if (direction)  
09F4:  BTFSS  x14.0
09F6:  BRA    0A2A
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
09F8:  CLRF   x23
09FA:  MOVFF  113,122
09FE:  CLRF   x25
0A00:  MOVLW  08
0A02:  MOVWF  x24
0A04:  MOVLB  0
0A06:  RCALL  02D2
0A08:  MOVFF  02,116
0A0C:  MOVFF  01,115
0A10:  MOVLW  04
0A12:  MOVLB  1
0A14:  ADDWF  x15,F
0A16:  MOVLW  00
0A18:  ADDWFC x16,F
0A1A:  MOVFF  115,FE9
0A1E:  MOVLW  04
0A20:  ADDWF  x16,W
0A22:  MOVWF  FEA
0A24:  MOVLW  84
0A26:  MOVWF  FEF
....................    } 
0A28:  BRA    0A4A
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
0A2A:  CLRF   x23
0A2C:  MOVFF  113,122
0A30:  CLRF   x25
0A32:  MOVLW  08
0A34:  MOVWF  x24
0A36:  MOVLB  0
0A38:  RCALL  02D2
0A3A:  MOVLB  1
0A3C:  MOVFF  01,FE9
0A40:  MOVLW  04
0A42:  ADDWF  02,W
0A44:  MOVWF  FEA
0A46:  MOVLW  84
0A48:  MOVWF  FEF
....................    } 
0A4A:  MOVLB  0
0A4C:  GOTO   0AFC (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0986:  MOVLB  1
0988:  BCF    x14.0
098A:  BTFSC  x13.7
098C:  BSF    x14.0
....................    endpoint &= 0x7F; 
098E:  BCF    x13.7
....................     
....................    if (direction)  
0990:  BTFSS  x14.0
0992:  BRA    09C6
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0994:  CLRF   x23
0996:  MOVFF  113,122
099A:  CLRF   x25
099C:  MOVLW  08
099E:  MOVWF  x24
09A0:  MOVLB  0
09A2:  RCALL  02D2
09A4:  MOVFF  02,116
09A8:  MOVFF  01,115
09AC:  MOVLW  04
09AE:  MOVLB  1
09B0:  ADDWF  x15,F
09B2:  MOVLW  00
09B4:  ADDWFC x16,F
09B6:  MOVFF  115,FE9
09BA:  MOVLW  04
09BC:  ADDWF  x16,W
09BE:  MOVWF  FEA
09C0:  MOVLW  88
09C2:  MOVWF  FEF
....................      #endif 
....................    } 
09C4:  BRA    09E4
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
09C6:  CLRF   x23
09C8:  MOVFF  113,122
09CC:  CLRF   x25
09CE:  MOVLW  08
09D0:  MOVWF  x24
09D2:  MOVLB  0
09D4:  RCALL  02D2
09D6:  MOVLB  1
09D8:  MOVFF  01,FE9
09DC:  MOVLW  04
09DE:  ADDWF  02,W
09E0:  MOVWF  FEA
09E2:  CLRF   FEF
....................    } 
09E4:  MOVLB  0
09E6:  GOTO   0AEC (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0A50:  MOVLB  1
0A52:  BCF    x14.0
0A54:  BTFSC  x13.7
0A56:  BSF    x14.0
....................    endpoint &= 0x7F; 
0A58:  BCF    x13.7
....................     
....................    if (direction)  
0A5A:  BTFSS  x14.0
0A5C:  BRA    0A90
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0A5E:  CLRF   x23
0A60:  MOVFF  113,122
0A64:  CLRF   x25
0A66:  MOVLW  08
0A68:  MOVWF  x24
0A6A:  MOVLB  0
0A6C:  RCALL  02D2
0A6E:  MOVFF  02,117
0A72:  MOVFF  01,116
0A76:  MOVLW  04
0A78:  MOVLB  1
0A7A:  ADDWF  x16,F
0A7C:  MOVLW  00
0A7E:  ADDWFC x17,F
0A80:  MOVFF  116,FE9
0A84:  MOVLW  04
0A86:  ADDWF  x17,W
0A88:  MOVWF  FEA
0A8A:  MOVFF  FEF,115
....................    } 
0A8E:  BRA    0AB0
....................    else  
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0A90:  CLRF   x23
0A92:  MOVFF  113,122
0A96:  CLRF   x25
0A98:  MOVLW  08
0A9A:  MOVWF  x24
0A9C:  MOVLB  0
0A9E:  RCALL  02D2
0AA0:  MOVLB  1
0AA2:  MOVFF  01,FE9
0AA6:  MOVLW  04
0AA8:  ADDWF  02,W
0AAA:  MOVWF  FEA
0AAC:  MOVFF  FEF,115
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0AB0:  BTFSS  x15.7
0AB2:  BRA    0AB8
0AB4:  BTFSC  x15.2
0AB6:  BRA    0ABC
0AB8:  MOVLW  00
0ABA:  BRA    0ABE
0ABC:  MOVLW  01
0ABE:  MOVWF  01
0AC0:  MOVLB  0
0AC2:  GOTO   0B14 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
0F8E:  MOVFF  114,F6E
....................     
....................    if (address)  
0F92:  MOVLB  1
0F94:  MOVF   x14,F
0F96:  BZ    0F9E
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0F98:  MOVLW  04
0F9A:  MOVWF  22
....................    } 
0F9C:  BRA    0FA2
....................    else  
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0F9E:  MOVLW  02
0FA0:  MOVWF  22
....................    } 
0FA2:  MOVLB  0
0FA4:  GOTO   0FB2 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
0604:  MOVLB  1
0606:  MOVF   x13,F
0608:  BNZ   0616
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
060A:  MOVLW  04
060C:  MOVWF  22
....................       usb_disable_endpoints(); 
060E:  MOVLB  0
0610:  RCALL  0364
....................    } 
0612:  BRA    0818
0614:  MOVLB  1
....................    else  
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
0616:  MOVLW  05
0618:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
061A:  MOVLW  04
061C:  MOVWF  x16
061E:  MOVLW  98
0620:  MOVWF  x15
....................       for (en=1; en<USB_NUM_UEP; en++)  
0622:  MOVLW  01
0624:  MOVWF  x14
0626:  MOVF   x14,W
0628:  SUBLW  0F
062A:  BTFSS  FD8.0
062C:  BRA    0818
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
062E:  MOVFF  114,11C
0632:  MOVLB  0
0634:  RCALL  02F4
....................          new_uep = 0; 
0636:  MOVLB  1
0638:  CLRF   x17
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
063A:  CLRF   03
063C:  MOVF   x14,W
063E:  MOVFF  FF2,11B
0642:  BCF    FF2.7
0644:  MOVLB  0
0646:  RCALL  00CE
0648:  MOVLB  1
064A:  BTFSC  x1B.7
064C:  BSF    FF2.7
064E:  SUBLW  FF
0650:  BZ    0730
....................          { 
....................             new_uep = 0x04; 
0652:  MOVLW  04
0654:  MOVWF  x17
....................             len = usb_ep_rx_size[en]; 
0656:  BCF    FD8.0
0658:  RLCF   x14,W
065A:  CLRF   03
065C:  MOVFF  FF2,11B
0660:  BCF    FF2.7
0662:  MOVLB  0
0664:  RCALL  011E
0666:  TBLRD*+
0668:  MOVFF  FF5,03
066C:  MOVLB  1
066E:  BTFSC  x1B.7
0670:  BSF    FF2.7
0672:  MOVWF  x18
0674:  MOVFF  03,119
....................             EP_BDxCNT_O(en) = len; 
0678:  CLRF   x23
067A:  MOVFF  114,122
067E:  CLRF   x25
0680:  MOVLW  08
0682:  MOVWF  x24
0684:  MOVLB  0
0686:  RCALL  02D2
0688:  MOVFF  01,11B
068C:  MOVLW  01
068E:  MOVLB  1
0690:  ADDWF  01,W
0692:  MOVWF  01
0694:  MOVLW  00
0696:  ADDWFC 02,W
0698:  MOVWF  03
069A:  MOVFF  01,FE9
069E:  MOVLW  04
06A0:  ADDWF  03,W
06A2:  MOVWF  FEA
06A4:  MOVFF  118,FEF
....................             EP_BDxADR_O(en) = addy; 
06A8:  CLRF   x23
06AA:  MOVFF  114,122
06AE:  CLRF   x25
06B0:  MOVLW  08
06B2:  MOVWF  x24
06B4:  MOVLB  0
06B6:  RCALL  02D2
06B8:  MOVFF  01,11B
06BC:  MOVLW  02
06BE:  MOVLB  1
06C0:  ADDWF  01,W
06C2:  MOVWF  01
06C4:  MOVLW  00
06C6:  ADDWFC 02,W
06C8:  MOVWF  03
06CA:  MOVFF  01,FE9
06CE:  MOVLW  04
06D0:  ADDWF  03,W
06D2:  MOVWF  FEA
06D4:  MOVFF  116,FEC
06D8:  MOVF   FED,F
06DA:  MOVFF  115,FEF
....................             addy += usb_ep_rx_size[en]; 
06DE:  BCF    FD8.0
06E0:  RLCF   x14,W
06E2:  CLRF   03
06E4:  MOVFF  FF2,11B
06E8:  BCF    FF2.7
06EA:  MOVLB  0
06EC:  RCALL  011E
06EE:  TBLRD*+
06F0:  MOVFF  FF5,03
06F4:  MOVLB  1
06F6:  BTFSC  x1B.7
06F8:  BSF    FF2.7
06FA:  ADDWF  x15,F
06FC:  MOVF   03,W
06FE:  ADDWFC x16,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0700:  MOVLW  88
0702:  MOVWF  x1A
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0704:  BTFSS  x19.0
0706:  BRA    070A
0708:  BSF    x1A.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
070A:  BTFSS  x19.1
070C:  BRA    0710
070E:  BSF    x1A.1
....................             EP_BDxST_O(en) = i; 
0710:  CLRF   x23
0712:  MOVFF  114,122
0716:  CLRF   x25
0718:  MOVLW  08
071A:  MOVWF  x24
071C:  MOVLB  0
071E:  RCALL  02D2
0720:  MOVLB  1
0722:  MOVFF  01,FE9
0726:  MOVLW  04
0728:  ADDWF  02,W
072A:  MOVWF  FEA
072C:  MOVFF  11A,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0730:  CLRF   03
0732:  MOVF   x14,W
0734:  MOVFF  FF2,11B
0738:  BCF    FF2.7
073A:  MOVLB  0
073C:  RCALL  00AE
073E:  MOVLB  1
0740:  BTFSC  x1B.7
0742:  BSF    FF2.7
0744:  SUBLW  FF
0746:  BZ    07DE
....................          { 
....................             new_uep |= 0x02; 
0748:  BSF    x17.1
....................             EP_BDxADR_I(en) = addy; 
074A:  CLRF   x23
074C:  MOVFF  114,122
0750:  CLRF   x25
0752:  MOVLW  08
0754:  MOVWF  x24
0756:  MOVLB  0
0758:  RCALL  02D2
075A:  MOVFF  02,11C
075E:  MOVFF  01,11B
0762:  MOVLW  04
0764:  MOVLB  1
0766:  ADDWF  x1B,F
0768:  MOVLW  00
076A:  ADDWFC x1C,F
076C:  MOVLW  02
076E:  ADDWF  x1B,W
0770:  MOVWF  01
0772:  MOVLW  00
0774:  ADDWFC x1C,W
0776:  MOVWF  03
0778:  MOVFF  01,FE9
077C:  MOVLW  04
077E:  ADDWF  03,W
0780:  MOVWF  FEA
0782:  MOVFF  116,FEC
0786:  MOVF   FED,F
0788:  MOVFF  115,FEF
....................             addy += usb_ep_tx_size[en]; 
078C:  BCF    FD8.0
078E:  RLCF   x14,W
0790:  CLRF   03
0792:  MOVFF  FF2,11B
0796:  BCF    FF2.7
0798:  MOVLB  0
079A:  RCALL  00EE
079C:  TBLRD*+
079E:  MOVFF  FF5,03
07A2:  MOVLB  1
07A4:  BTFSC  x1B.7
07A6:  BSF    FF2.7
07A8:  ADDWF  x15,F
07AA:  MOVF   03,W
07AC:  ADDWFC x16,F
....................             EP_BDxST_I(en) = 0x40; 
07AE:  CLRF   x23
07B0:  MOVFF  114,122
07B4:  CLRF   x25
07B6:  MOVLW  08
07B8:  MOVWF  x24
07BA:  MOVLB  0
07BC:  RCALL  02D2
07BE:  MOVFF  02,11C
07C2:  MOVFF  01,11B
07C6:  MOVLW  04
07C8:  MOVLB  1
07CA:  ADDWF  x1B,F
07CC:  MOVLW  00
07CE:  ADDWFC x1C,F
07D0:  MOVFF  11B,FE9
07D4:  MOVLW  04
07D6:  ADDWF  x1C,W
07D8:  MOVWF  FEA
07DA:  MOVLW  40
07DC:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
07DE:  MOVF   x17,W
07E0:  SUBLW  06
07E2:  BNZ   07E8
07E4:  MOVLW  0E
07E6:  MOVWF  x17
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
07E8:  CLRF   03
07EA:  MOVF   x14,W
07EC:  MOVFF  FF2,11B
07F0:  BCF    FF2.7
07F2:  MOVLB  0
07F4:  RCALL  00AE
07F6:  MOVLB  1
07F8:  BTFSC  x1B.7
07FA:  BSF    FF2.7
07FC:  SUBLW  01
07FE:  BZ    0802
0800:  BSF    x17.4
....................           
....................          UEP(en) = new_uep; 
0802:  CLRF   03
0804:  MOVF   x14,W
0806:  ADDLW  70
0808:  MOVWF  FE9
080A:  MOVLW  0F
080C:  ADDWFC 03,W
080E:  MOVWF  FEA
0810:  MOVFF  117,FEF
0814:  INCF   x14,F
0816:  BRA    0626
0818:  MOVLB  0
....................       } 
....................    } 
081A:  GOTO   08C6 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
02F4:  CLRF   03
02F6:  MOVLB  1
02F8:  MOVF   x1C,W
02FA:  ADDLW  70
02FC:  MOVWF  FE9
02FE:  MOVLW  0F
0300:  ADDWFC 03,W
0302:  MOVWF  FEA
0304:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0306:  MOVFF  11C,11D
030A:  MOVLB  0
030C:  RCALL  0270
030E:  MOVF   01,F
0310:  BZ    0362
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
0312:  MOVLB  1
0314:  CLRF   x23
0316:  MOVFF  11C,122
031A:  CLRF   x25
031C:  MOVLW  08
031E:  MOVWF  x24
0320:  MOVLB  0
0322:  RCALL  02D2
0324:  MOVLB  1
0326:  MOVFF  01,FE9
032A:  MOVLW  04
032C:  ADDWF  02,W
032E:  MOVWF  FEA
0330:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
0332:  CLRF   x23
0334:  MOVFF  11C,122
0338:  CLRF   x25
033A:  MOVLW  08
033C:  MOVWF  x24
033E:  MOVLB  0
0340:  RCALL  02D2
0342:  MOVFF  02,11E
0346:  MOVFF  01,11D
034A:  MOVLW  04
034C:  MOVLB  1
034E:  ADDWF  x1D,F
0350:  MOVLW  00
0352:  ADDWFC x1E,F
0354:  MOVFF  11D,FE9
0358:  MOVLW  04
035A:  ADDWF  x1E,W
035C:  MOVWF  FEA
035E:  CLRF   FEF
0360:  MOVLB  0
....................    } 
0362:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
0364:  MOVLW  01
0366:  MOVLB  1
0368:  MOVWF  x1B
036A:  MOVF   x1B,W
036C:  SUBLW  0F
036E:  BNC   037E
....................       usb_disable_endpoint(i); 
0370:  MOVFF  11B,11C
0374:  MOVLB  0
0376:  RCALL  02F4
0378:  MOVLB  1
037A:  INCF   x1B,F
037C:  BRA    036A
037E:  MOVLB  0
0380:  RETURN 0
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
11AA:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
11AC:  MOVF   22,F
11AE:  BTFSC  FD8.2
11B0:  BRA    1224
....................    if (UIR)  
11B2:  MOVF   F68,F
11B4:  BTFSC  FD8.2
11B6:  BRA    1224
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
11B8:  BTFSS  F68.2
11BA:  BRA    11C2
11BC:  BTFSC  F69.2
11BE:  GOTO   022A
....................  
....................       if (UCON_SUSPND) return; 
11C2:  BTFSC  F6D.1
11C4:  BRA    1224
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
11C6:  BTFSS  F68.5
11C8:  BRA    11D0
11CA:  BTFSC  F69.5
11CC:  GOTO   025A
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
11D0:  BTFSS  F68.1
11D2:  BRA    11DA
11D4:  BTFSC  F69.1
11D6:  GOTO   0268
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
11DA:  BTFSS  F68.0
11DC:  BRA    11E4
11DE:  BTFSC  F69.0
11E0:  GOTO   042E
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
11E4:  BTFSS  F68.4
11E6:  BRA    11EE
11E8:  BTFSC  F69.4
11EA:  GOTO   0458
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
11EE:  BTFSS  F68.6
11F0:  BRA    11F8
11F2:  BTFSC  F69.6
11F4:  GOTO   0462
....................  
....................       TRNAttempts = 0; 
11F8:  MOVLB  1
11FA:  CLRF   x10
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
11FC:  BTFSS  F68.3
11FE:  BRA    1214
1200:  BTFSS  F69.3
1202:  BRA    1214
....................          { 
....................             USTATCopy = U1STAT; 
1204:  MOVFF  F6C,21
....................             usb_clear_trn(); 
1208:  MOVLB  0
120A:  CALL   0004
....................             usb_isr_tok_dne(); 
120E:  BRA    10B2
....................          } 
1210:  BRA    1218
1212:  MOVLB  1
....................          else 
....................             break; 
1214:  BRA    1222
1216:  MOVLB  0
....................       } while (TRNAttempts++ < 4); 
1218:  MOVLB  1
121A:  MOVF   x10,W
121C:  INCF   x10,F
121E:  SUBLW  03
1220:  BC    11FC
1222:  MOVLB  0
....................  
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
1224:  GOTO   006C
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
0462:  BCF    F68.6
0464:  GOTO   11F8 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
042E:  CLRF   F6A
....................    UIR = 0; 
0430:  CLRF   F68
....................    UEIE = 0x9F; 
0432:  MOVLW  9F
0434:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0436:  MOVLW  3D
0438:  MOVWF  F69
....................  
....................    UADDR = 0; 
043A:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
043C:  RCALL  0364
....................     
....................    usb_token_reset(); 
043E:  RCALL  03FE
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
0440:  MOVLW  16
0442:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
0444:  BTFSS  F68.3
0446:  BRA    044C
....................    { 
....................       usb_clear_trn(); 
0448:  RCALL  0004
044A:  BRA    0444
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
044C:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
044E:  RCALL  023A
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0450:  MOVLW  03
0452:  MOVWF  22
0454:  GOTO   11E4 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
023A:  MOVLW  40
023C:  MOVLB  4
023E:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0240:  MOVLW  04
0242:  MOVWF  x03
0244:  MOVLW  18
0246:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0248:  MOVLW  88
024A:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
024C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
024E:  MOVLW  04
0250:  MOVWF  x07
0252:  MOVLW  58
0254:  MOVWF  x06
0256:  MOVLB  0
0258:  RETURN 0
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0268:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
026A:  BCF    F68.1
026C:  GOTO   11DA (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0458:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
045A:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
045C:  BSF    F6D.1
045E:  GOTO   11EE (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
022A:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
022C:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
022E:  BTFSS  F68.2
0230:  BRA    0236
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0232:  BCF    F68.2
0234:  BRA    022E
....................    } 
0236:  GOTO   11C2 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
025A:  BTFSS  F70.0
025C:  BRA    0262
....................    { 
....................       usb_init_ep0_setup(); 
025E:  RCALL  023A
....................       bit_clear(UEP(0), 0); 
0260:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0262:  BCF    F68.5
0264:  GOTO   11D0 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0468:  MOVFF  116,23
046C:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
0B32:  MOVLW  FE
0B34:  MOVWF  23
0B36:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
046E:  SETF   23
0470:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
10B2:  RRCF   21,W
10B4:  MOVLB  1
10B6:  MOVWF  x11
10B8:  RRCF   x11,F
10BA:  RRCF   x11,F
10BC:  MOVLW  1F
10BE:  ANDWF  x11,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
10C0:  MOVF   21,F
10C2:  BNZ   1160
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
10C4:  MOVLB  4
10C6:  MOVF   x00,W
10C8:  ANDLW  3C
10CA:  MOVLB  1
10CC:  MOVWF  x12
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
10CE:  MOVLW  43
10D0:  MOVLB  4
10D2:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
10D4:  MOVLB  1
10D6:  MOVF   x12,W
10D8:  SUBLW  34
10DA:  BNZ   1126
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
10DC:  MOVLB  4
10DE:  MOVF   x04,W
10E0:  ANDLW  80
10E2:  BZ    10E6
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
10E4:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
10E6:  MOVLB  0
10E8:  BRA    0BE6
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
10EA:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
10EC:  INCFSZ 23,W
10EE:  BRA    10FE
....................             usb_flush_out(0, USB_DTS_STALL); 
10F0:  MOVLB  1
10F2:  CLRF   x14
10F4:  MOVLW  03
10F6:  MOVWF  x15
10F8:  MOVLB  0
10FA:  RCALL  0C18
10FC:  BRA    1122
....................          else  
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
10FE:  MOVLB  1
1100:  CLRF   x14
1102:  MOVLW  02
1104:  MOVWF  x15
1106:  MOVLB  0
1108:  RCALL  0C18
....................             if (__setup_0_tx_size != 0xFE) 
110A:  MOVF   23,W
110C:  SUBLW  FE
110E:  BZ    1122
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
1110:  MOVLB  1
1112:  CLRF   x1C
1114:  CLRF   x1E
1116:  MOVFF  23,11D
111A:  MOVLW  04
111C:  MOVWF  x1F
111E:  MOVLB  0
1120:  RCALL  0D78
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
1122:  BRA    115C
1124:  MOVLB  1
....................       else if (pidKey == USB_PIC_PID_OUT)  
1126:  MOVF   x12,W
1128:  SUBLW  04
112A:  BNZ   115E
....................       { 
....................          usb_isr_tok_out_dne(0); 
112C:  CLRF   x13
112E:  MOVLB  0
1130:  RCALL  0F70
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
1132:  MOVLB  1
1134:  CLRF   x14
1136:  MOVLW  02
1138:  MOVWF  x15
113A:  MOVLB  0
113C:  RCALL  0C18
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
113E:  MOVF   23,W
1140:  SUBLW  FE
1142:  BZ    115C
1144:  INCFSZ 23,W
1146:  BRA    114A
1148:  BRA    115C
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
114A:  MOVLB  1
114C:  CLRF   x1C
114E:  CLRF   x1E
1150:  MOVFF  23,11D
1154:  MOVLW  01
1156:  MOVWF  x1F
1158:  MOVLB  0
115A:  RCALL  0D78
....................          } 
....................       } 
115C:  MOVLB  1
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
115E:  BRA    11A4
....................    else if (USTATCopy == USTAT_IN_E0)  
1160:  MOVF   21,W
1162:  SUBLW  04
1164:  BNZ   118A
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
1166:  SETF   23
....................       usb_isr_tok_in_dne(0); 
1168:  CLRF   x13
116A:  MOVLB  0
116C:  RCALL  1080
....................       if (__setup_0_tx_size!=0xFF) 
116E:  INCFSZ 23,W
1170:  BRA    1174
1172:  BRA    1186
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
1174:  MOVLB  1
1176:  CLRF   x1C
1178:  CLRF   x1E
117A:  MOVFF  23,11D
117E:  MOVLW  02
1180:  MOVWF  x1F
1182:  MOVLB  0
1184:  RCALL  0D78
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
1186:  BRA    11A2
1188:  MOVLB  1
....................    else  
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
118A:  BTFSC  21.2
118C:  BRA    119A
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
118E:  MOVFF  111,113
1192:  MOVLB  0
1194:  RCALL  0F70
....................       } 
1196:  BRA    11A2
1198:  MOVLB  1
....................       else  
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
119A:  MOVFF  111,113
119E:  MOVLB  0
11A0:  RCALL  1080
11A2:  MOVLB  1
....................       } 
....................    } 
11A4:  MOVLB  0
11A6:  GOTO   1210 (RETURN)
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1744:  MOVF   18,W
1746:  MOVWF  01
1748:  GOTO   3190 (RETURN)
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
03FE:  CLRF   28
0400:  CLRF   27
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
0402:  MOVLB  1
0404:  CLRF   x11
0406:  MOVF   x11,W
0408:  SUBLW  01
040A:  BNC   0420
....................       USB_Interface[i] = 0;   //reset each interface to default 
040C:  CLRF   03
040E:  MOVF   x11,W
0410:  ADDLW  29
0412:  MOVWF  FE9
0414:  MOVLW  00
0416:  ADDWFC 03,W
0418:  MOVWF  FEA
041A:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
041C:  INCF   x11,F
041E:  BRA    0406
....................    usb_cdc_init(); 
0420:  MOVLB  0
0422:  RCALL  0382
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0424:  CLRF   18
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0426:  MOVLW  01
0428:  MOVWF  19
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
042A:  CLRF   17
042C:  RETURN 0
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0270:  MOVLB  1
0272:  BCF    x1E.0
0274:  BTFSC  x1D.7
0276:  BSF    x1E.0
....................     
....................    endpoint &= 0x7F; 
0278:  BCF    x1D.7
....................     
....................    if (endpoint > 16) 
027A:  MOVF   x1D,W
027C:  SUBLW  10
027E:  BC    0286
....................       return(FALSE); 
0280:  MOVLW  00
0282:  MOVWF  01
0284:  BRA    02CE
....................     
....................    if (direction) { //IN 
0286:  BTFSS  x1E.0
0288:  BRA    02AE
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
028A:  CLRF   03
028C:  MOVF   x1D,W
028E:  MOVFF  FF2,11F
0292:  BCF    FF2.7
0294:  MOVLB  0
0296:  RCALL  00AE
0298:  MOVLB  1
029A:  BTFSC  x1F.7
029C:  BSF    FF2.7
029E:  SUBLW  FF
02A0:  BNZ   02A6
02A2:  MOVLW  00
02A4:  BRA    02A8
02A6:  MOVLW  01
02A8:  MOVWF  01
02AA:  BRA    02CE
....................    } 
02AC:  BRA    02CE
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
02AE:  CLRF   03
02B0:  MOVF   x1D,W
02B2:  MOVFF  FF2,11F
02B6:  BCF    FF2.7
02B8:  MOVLB  0
02BA:  RCALL  00CE
02BC:  MOVLB  1
02BE:  BTFSC  x1F.7
02C0:  BSF    FF2.7
02C2:  SUBLW  FF
02C4:  BNZ   02CA
02C6:  MOVLW  00
02C8:  BRA    02CC
02CA:  MOVLW  01
02CC:  MOVWF  01
....................    } 
02CE:  MOVLB  0
02D0:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
1080:  MOVLB  1
1082:  MOVF   x13,F
1084:  BNZ   10A2
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
1086:  DECFSZ 17,W
1088:  BRA    1094
108A:  MOVLB  0
108C:  CALL   0472
1090:  BRA    109E
1092:  MOVLB  1
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
1094:  MOVF   17,W
1096:  SUBLW  02
1098:  BNZ   10A0
109A:  MOVLB  0
109C:  BRA    0FA8
109E:  MOVLB  1
....................    } 
....................   #if USB_CDC_DEVICE 
10A0:  BRA    10AE
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
10A2:  MOVF   x13,W
10A4:  SUBLW  02
10A6:  BNZ   10AE
....................       usb_isr_tok_in_cdc_data_dne(); 
10A8:  MOVLB  0
10AA:  BRA    107A
10AC:  MOVLB  1
....................   } 
....................   #endif 
10AE:  MOVLB  0
10B0:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0F70:  MOVLB  1
0F72:  MOVF   x13,F
0F74:  BNZ   0F7E
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0F76:  MOVLB  0
0F78:  BRA    0E9C
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
0F7A:  BRA    0F88
0F7C:  MOVLB  1
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0F7E:  MOVF   x13,W
0F80:  SUBLW  02
0F82:  BNZ   0F8A
....................       usb_isr_tok_out_cdc_data_dne(); 
0F84:  MOVLB  0
0F86:  BRA    0F54
0F88:  MOVLB  1
....................    } 
....................   #endif 
0F8A:  MOVLB  0
0F8C:  RETURN 0
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0BE6:  CLRF   17
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0BE8:  MOVLB  4
0BEA:  MOVF   x18,W
0BEC:  ANDLW  7F
0BEE:  XORLW  00
0BF0:  MOVLB  0
0BF2:  BZ    0C02
0BF4:  XORLW  01
0BF6:  BZ    0C06
0BF8:  XORLW  03
0BFA:  BZ    0C0A
0BFC:  XORLW  23
0BFE:  BZ    0C0E
0C00:  BRA    0C12
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0C02:  BRA    081E
....................          break; 
0C04:  BRA    0C14
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0C06:  BRA    08DA
....................          break; 
0C08:  BRA    0C14
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0C0A:  BRA    0AC6
....................          break; 
0C0C:  BRA    0C14
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
0C0E:  BRA    0B38
....................         #endif 
....................          break; 
0C10:  BRA    0C14
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0C12:  RCALL  046E
....................          break; 
....................    } 
0C14:  GOTO   10EA (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
081E:  MOVLB  4
0820:  MOVF   x19,W
0822:  XORLW  00
0824:  MOVLB  0
0826:  BZ    0842
0828:  XORLW  01
082A:  BZ    0856
082C:  XORLW  02
082E:  BZ    0872
0830:  XORLW  06
0832:  BZ    088C
0834:  XORLW  03
0836:  BZ    089E
0838:  XORLW  0E
083A:  BZ    08A2
083C:  XORLW  01
083E:  BZ    08B2
0840:  BRA    08D4
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0842:  MOVFF  19,458
....................             usb_ep0_tx_buffer[1]=0; 
0846:  MOVLB  4
0848:  CLRF   x59
....................             usb_request_send_response(2); 
084A:  MOVLW  02
084C:  MOVLB  1
084E:  MOVWF  x16
0850:  MOVLB  0
0852:  RCALL  0468
....................             break; 
0854:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0856:  MOVLB  4
0858:  DECFSZ x1A,W
085A:  BRA    086C
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
085C:  MOVLW  01
085E:  ANDWF  19,F
....................                usb_put_0len_0(); 
0860:  MOVLB  1
0862:  CLRF   x16
0864:  MOVLB  0
0866:  RCALL  0468
....................             } 
0868:  BRA    0870
086A:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
086C:  MOVLB  0
086E:  RCALL  046E
....................             break; 
0870:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0872:  MOVLB  4
0874:  DECFSZ x1A,W
0876:  BRA    0886
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0878:  BSF    19.1
....................                usb_put_0len_0(); 
087A:  MOVLB  1
087C:  CLRF   x16
087E:  MOVLB  0
0880:  RCALL  0468
....................             } 
0882:  BRA    088A
0884:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
0886:  MOVLB  0
0888:  RCALL  046E
....................             break; 
088A:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
088C:  MOVLW  02
088E:  MOVWF  17
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
0890:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
0894:  MOVLB  1
0896:  CLRF   x16
0898:  MOVLB  0
089A:  RCALL  0468
....................             break; 
089C:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
089E:  BRA    051E
....................             break; 
08A0:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
08A2:  MOVFF  18,458
....................             usb_request_send_response(1); 
08A6:  MOVLW  01
08A8:  MOVLB  1
08AA:  MOVWF  x16
08AC:  MOVLB  0
08AE:  RCALL  0468
....................             break; 
08B0:  BRA    08D6
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
08B2:  MOVLB  4
08B4:  MOVF   x1A,W
08B6:  SUBLW  01
08B8:  BNC   08D0
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
08BA:  MOVFF  41A,18
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
08BE:  MOVFF  41A,113
08C2:  MOVLB  0
08C4:  BRA    0604
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
08C6:  MOVLB  1
08C8:  CLRF   x16
08CA:  MOVLB  0
08CC:  RCALL  0468
08CE:  MOVLB  4
....................             } 
....................             break; 
08D0:  MOVLB  0
08D2:  BRA    08D6
....................  
....................       default: 
....................             usb_request_stall(); 
08D4:  RCALL  046E
....................             break; 
....................    } 
08D6:  GOTO   0C14 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
08DA:  MOVFF  18,113
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
08DE:  MOVLB  4
08E0:  MOVF   x19,W
08E2:  XORLW  00
08E4:  MOVLB  0
08E6:  BZ    08F2
08E8:  XORLW  0A
08EA:  BZ    0904
08EC:  XORLW  01
08EE:  BZ    0954
08F0:  BRA    0980
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
08F2:  MOVLB  4
08F4:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0; 
08F6:  CLRF   x59
....................             usb_request_send_response(2); 
08F8:  MOVLW  02
08FA:  MOVLB  1
08FC:  MOVWF  x16
08FE:  MOVLB  0
0900:  RCALL  0468
....................             break; 
0902:  BRA    0982
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0904:  MOVLB  1
0906:  MOVF   x13,F
0908:  BZ    094E
090A:  MOVLW  01
090C:  SUBWF  x13,W
090E:  CLRF   03
0910:  MOVFF  FF2,114
0914:  BCF    FF2.7
0916:  MOVLB  0
0918:  RCALL  01A2
091A:  MOVLB  1
091C:  BTFSC  x14.7
091E:  BSF    FF2.7
0920:  MOVWF  01
0922:  MOVLB  4
0924:  SUBWF  x1C,W
0926:  BTFSS  FD8.0
0928:  BRA    092E
092A:  MOVLB  1
092C:  BRA    094E
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
092E:  CLRF   03
0930:  MOVF   x1C,W
0932:  ADDLW  29
0934:  MOVWF  FE9
0936:  MOVLW  00
0938:  ADDWFC 03,W
093A:  MOVWF  FEA
093C:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back 
0940:  MOVLW  01
0942:  MOVLB  1
0944:  MOVWF  x16
0946:  MOVLB  0
0948:  RCALL  0468
....................             } 
094A:  BRA    0952
094C:  MOVLB  1
....................             else 
....................                usb_request_stall(); 
094E:  MOVLB  0
0950:  RCALL  046E
....................             break; 
0952:  BRA    0982
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0954:  MOVLB  1
0956:  MOVF   x13,F
0958:  BZ    097A
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
095A:  CLRF   03
095C:  MOVLB  4
095E:  MOVF   x1C,W
0960:  ADDLW  29
0962:  MOVWF  FE9
0964:  MOVLW  00
0966:  ADDWFC 03,W
0968:  MOVWF  FEA
096A:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
096E:  MOVLB  1
0970:  CLRF   x16
0972:  MOVLB  0
0974:  RCALL  0468
....................             } 
0976:  BRA    097E
0978:  MOVLB  1
....................             else 
....................                usb_request_stall(); 
097A:  MOVLB  0
097C:  RCALL  046E
....................             break; 
097E:  BRA    0982
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0980:  RCALL  046E
....................             break; 
....................    } 
0982:  GOTO   0C14 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0AC6:  MOVFF  41C,11D
0ACA:  CALL   0270
0ACE:  MOVF   01,F
0AD0:  BZ    0B2E
....................       switch(usb_ep0_rx_buffer[1]) { 
0AD2:  MOVLB  4
0AD4:  MOVF   x19,W
0AD6:  XORLW  01
0AD8:  MOVLB  0
0ADA:  BZ    0AE6
0ADC:  XORLW  02
0ADE:  BZ    0AF6
0AE0:  XORLW  03
0AE2:  BZ    0B06
0AE4:  BRA    0B2C
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0AE6:  MOVFF  41C,113
0AEA:  BRA    0986
....................                usb_put_0len_0(); 
0AEC:  MOVLB  1
0AEE:  CLRF   x16
0AF0:  MOVLB  0
0AF2:  RCALL  0468
....................                break; 
0AF4:  BRA    0B2E
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0AF6:  MOVFF  41C,113
0AFA:  BRA    09EA
....................                      usb_put_0len_0(); 
0AFC:  MOVLB  1
0AFE:  CLRF   x16
0B00:  MOVLB  0
0B02:  RCALL  0468
....................                      break; 
0B04:  BRA    0B2E
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0B06:  MOVLB  4
0B08:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0; 
0B0A:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0B0C:  MOVFF  41C,113
0B10:  MOVLB  0
0B12:  BRA    0A50
0B14:  MOVF   01,F
0B16:  BZ    0B20
....................                   usb_ep0_tx_buffer[0]=1; 
0B18:  MOVLW  01
0B1A:  MOVLB  4
0B1C:  MOVWF  x58
0B1E:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
0B20:  MOVLW  02
0B22:  MOVLB  1
0B24:  MOVWF  x16
0B26:  MOVLB  0
0B28:  RCALL  0468
....................                break; 
0B2A:  BRA    0B2E
....................  
....................          default: 
....................             usb_request_stall(); 
0B2C:  RCALL  046E
....................             break; 
....................       } 
....................    } 
0B2E:  GOTO   0C14 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
051E:  CLRF   26
0520:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
0522:  CLRF   1A
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
0524:  MOVLB  4
0526:  MOVF   x1B,W
0528:  XORLW  01
052A:  MOVLB  0
052C:  BZ    053C
052E:  XORLW  03
0530:  BZ    0548
0532:  XORLW  01
0534:  BZ    0550
0536:  XORLW  22
0538:  BZ    058C
053A:  BRA    05DE
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
053C:  CLRF   28
053E:  MOVLW  12
0540:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
0542:  MOVLW  03
0544:  MOVWF  1A
....................             break; 
0546:  BRA    05E2
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
0548:  CLRF   28
054A:  MOVLW  43
054C:  MOVWF  27
....................             break; 
054E:  BRA    05E2
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0550:  MOVLW  02
0552:  MOVWF  1A
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
0554:  CLRF   03
0556:  MOVLB  4
0558:  MOVF   x1A,W
055A:  ADDLW  1B
055C:  MOVWF  FE9
055E:  MOVLW  00
0560:  ADDWFC 03,W
0562:  MOVWF  FEA
0564:  CLRF   26
0566:  MOVFF  FEF,25
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
056A:  MOVFF  26,03
056E:  MOVF   25,W
0570:  MOVFF  FF2,113
0574:  BCF    FF2.7
0576:  MOVLB  0
0578:  RCALL  01EE
057A:  MOVLB  1
057C:  BTFSC  x13.7
057E:  BSF    FF2.7
0580:  CLRF   03
0582:  MOVWF  27
0584:  MOVFF  03,28
....................             break; 
0588:  MOVLB  0
058A:  BRA    05E2
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
058C:  CLRF   03
058E:  MOVLB  4
0590:  MOVF   x1A,W
0592:  MOVFF  FF2,113
0596:  BCF    FF2.7
0598:  MOVLB  0
059A:  RCALL  01B4
059C:  MOVLB  1
059E:  BTFSC  x13.7
05A0:  BSF    FF2.7
05A2:  CLRF   03
05A4:  MOVWF  25
05A6:  MOVFF  03,26
....................             if (usb_getdesc_ptr!=0xFF) { 
05AA:  INCFSZ 25,W
05AC:  BRA    05B2
05AE:  MOVF   26,F
05B0:  BZ    05D8
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
05B2:  MOVFF  26,03
05B6:  MOVF   25,W
05B8:  MOVFF  FF2,113
05BC:  BCF    FF2.7
05BE:  MOVLB  0
05C0:  RCALL  014E
05C2:  MOVLB  1
05C4:  BTFSC  x13.7
05C6:  BSF    FF2.7
05C8:  CLRF   03
05CA:  MOVWF  27
05CC:  MOVFF  03,28
....................                break; 
05D0:  MOVLB  0
05D2:  BRA    05E2
....................             } 
05D4:  BRA    05DE
05D6:  MOVLB  1
....................             else { 
....................                usb_request_stall(); 
05D8:  MOVLB  0
05DA:  RCALL  046E
....................                return; 
05DC:  BRA    0600
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
05DE:  RCALL  046E
....................             return; 
05E0:  BRA    0600
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
05E2:  MOVLB  4
05E4:  MOVF   x1F,F
05E6:  BNZ   05F8
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
05E8:  MOVF   28,F
05EA:  BNZ   05F2
05EC:  MOVF   27,W
05EE:  SUBWF  x1E,W
05F0:  BC    05F8
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
05F2:  CLRF   28
05F4:  MOVFF  41E,27
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
05F8:  MOVLW  01
05FA:  MOVWF  17
....................    usb_copy_desc_seg_to_ep(); 
05FC:  MOVLB  0
05FE:  RCALL  0472
0600:  GOTO   08D6 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0FA8:  CLRF   18
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0FAA:  CLRF   17
....................    usb_set_address(USB_address_pending); 
0FAC:  MOVFF  24,114
0FB0:  BRA    0F8E
....................    #endif 
0FB2:  GOTO   109E (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0472:  MOVLB  1
0474:  CLRF   x14
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
0476:  MOVF   27,W
0478:  IORWF  28,W
047A:  BZ    0506
047C:  MOVF   x14,W
047E:  SUBLW  3F
0480:  BNC   0506
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
0482:  MOVF   1A,W
0484:  XORLW  00
0486:  MOVLB  0
0488:  BZ    0494
048A:  XORLW  02
048C:  BZ    04AE
048E:  XORLW  01
0490:  BZ    04C8
0492:  BRA    04E0
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0494:  MOVFF  26,03
0498:  MOVF   25,W
049A:  MOVFF  FF2,116
049E:  BCF    FF2.7
04A0:  RCALL  014E
04A2:  MOVLB  1
04A4:  BTFSC  x16.7
04A6:  BSF    FF2.7
04A8:  MOVWF  x15
....................             break; 
04AA:  MOVLB  0
04AC:  BRA    04E0
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
04AE:  MOVFF  26,03
04B2:  MOVF   25,W
04B4:  MOVFF  FF2,116
04B8:  BCF    FF2.7
04BA:  RCALL  01EE
04BC:  MOVLB  1
04BE:  BTFSC  x16.7
04C0:  BSF    FF2.7
04C2:  MOVWF  x15
....................             break; 
04C4:  MOVLB  0
04C6:  BRA    04E0
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
04C8:  MOVFF  26,03
04CC:  MOVF   25,W
04CE:  MOVFF  FF2,116
04D2:  BCF    FF2.7
04D4:  RCALL  01CC
04D6:  MOVLB  1
04D8:  BTFSC  x16.7
04DA:  BSF    FF2.7
04DC:  MOVWF  x15
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
04DE:  MOVLB  0
....................       } 
....................       usb_getdesc_ptr++; 
04E0:  INCF   25,F
04E2:  BTFSC  FD8.2
04E4:  INCF   26,F
....................       usb_getdesc_len--; 
04E6:  MOVF   27,W
04E8:  BTFSC  FD8.2
04EA:  DECF   28,F
04EC:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c; 
04EE:  MOVLB  1
04F0:  MOVF   x14,W
04F2:  INCF   x14,F
04F4:  ADDLW  58
04F6:  MOVWF  FE9
04F8:  MOVLW  04
04FA:  MOVWF  FEA
04FC:  BTFSC  FD8.0
04FE:  INCF   FEA,F
0500:  MOVFF  115,FEF
0504:  BRA    0476
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
0506:  MOVF   27,W
0508:  IORWF  28,W
050A:  BNZ   0514
050C:  MOVF   x14,W
050E:  SUBLW  40
0510:  BZ    0514
....................          USB_stack_status.dev_req = NONE; 
0512:  CLRF   17
....................    } 
....................  
....................    usb_request_send_response(i); 
0514:  MOVFF  114,116
0518:  MOVLB  0
051A:  RCALL  0468
051C:  RETURN 0
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDC to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #else 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE]; 
.................... #endif 
....................  
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  typedef unsigned int16 usb_cdc_tx_t; 
.................... #else 
....................  typedef unsigned int8 usb_cdc_tx_t; 
.................... #endif 
....................  
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin; 
....................  
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... /* 
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
.................... */ 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
0E9C:  MOVF   x7E,W
0E9E:  XORLW  01
0EA0:  BZ    0EA8
0EA2:  XORLW  03
0EA4:  BZ    0ED0
0EA6:  BRA    0EF8
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
0EA8:  CLRF   FEA
0EAA:  MOVLW  34
0EAC:  MOVWF  FE9
0EAE:  MOVLW  04
0EB0:  MOVWF  FE2
0EB2:  MOVLW  18
0EB4:  MOVWF  FE1
0EB6:  MOVLW  08
0EB8:  MOVWF  01
0EBA:  MOVFF  FE6,FEE
0EBE:  DECFSZ 01,F
0EC0:  BRA    0EBA
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
0EC2:  MOVLB  1
0EC4:  CLRF   x16
0EC6:  MOVLB  0
0EC8:  CALL   0468
....................          __usb_cdc_state=0; 
0ECC:  CLRF   x7E
....................         #endif 
....................          break; 
0ECE:  BRA    0EFA
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0ED0:  CLRF   FEA
0ED2:  MOVLW  2B
0ED4:  MOVWF  FE9
0ED6:  MOVLW  04
0ED8:  MOVWF  FE2
0EDA:  MOVLW  18
0EDC:  MOVWF  FE1
0EDE:  MOVLW  07
0EE0:  MOVWF  01
0EE2:  MOVFF  FE6,FEE
0EE6:  DECFSZ 01,F
0EE8:  BRA    0EE2
....................          __usb_cdc_state=0; 
0EEA:  CLRF   x7E
....................          usb_put_0len_0(); 
0EEC:  MOVLB  1
0EEE:  CLRF   x16
0EF0:  MOVLB  0
0EF2:  CALL   0468
....................          break; 
0EF6:  BRA    0EFA
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0EF8:  CLRF   x7E
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
....................    } 
0EFA:  GOTO   0F7A (RETURN)
.................... } 
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
0B38:  MOVLB  4
0B3A:  DECFSZ x1C,W
0B3C:  BRA    0B40
0B3E:  BRA    0B44
0B40:  MOVF   x1C,F
0B42:  BNZ   0BE0
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
0B44:  MOVF   x19,W
0B46:  XORLW  00
0B48:  MOVLB  0
0B4A:  BZ    0B62
0B4C:  XORLW  01
0B4E:  BZ    0B6A
0B50:  XORLW  21
0B52:  BZ    0B8C
0B54:  XORLW  01
0B56:  BZ    0B96
0B58:  XORLW  03
0B5A:  BZ    0BBC
0B5C:  XORLW  01
0B5E:  BZ    0BCA
0B60:  BRA    0BDC
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
0B62:  MOVLW  01
0B64:  MOVWF  x7E
....................             usb_request_get_data(); 
0B66:  RCALL  0B32
....................             break; 
0B68:  BRA    0BDE
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
0B6A:  MOVLW  04
0B6C:  MOVWF  FEA
0B6E:  MOVLW  58
0B70:  MOVWF  FE9
0B72:  CLRF   FE2
0B74:  MOVLW  34
0B76:  MOVWF  FE1
0B78:  MOVLW  08
0B7A:  MOVWF  01
0B7C:  MOVFF  FE6,FEE
0B80:  DECFSZ 01,F
0B82:  BRA    0B7C
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
0B84:  MOVFF  41E,116
0B88:  RCALL  0468
....................             break; 
0B8A:  BRA    0BDE
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
0B8C:  MOVLW  02
0B8E:  MOVWF  x7E
....................             usb_cdc_got_set_line_coding=TRUE; 
0B90:  BSF    x7C.0
....................             usb_request_get_data(); 
0B92:  RCALL  0B32
....................             break; 
0B94:  BRA    0BDE
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0B96:  MOVLW  04
0B98:  MOVWF  FEA
0B9A:  MOVLW  58
0B9C:  MOVWF  FE9
0B9E:  CLRF   FE2
0BA0:  MOVLW  2B
0BA2:  MOVWF  FE1
0BA4:  MOVLW  07
0BA6:  MOVWF  01
0BA8:  MOVFF  FE6,FEE
0BAC:  DECFSZ 01,F
0BAE:  BRA    0BA8
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0BB0:  MOVLW  07
0BB2:  MOVLB  1
0BB4:  MOVWF  x16
0BB6:  MOVLB  0
0BB8:  RCALL  0468
....................             break; 
0BBA:  BRA    0BDE
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0BBC:  MOVFF  41A,7D
....................             usb_put_0len_0(); 
0BC0:  MOVLB  1
0BC2:  CLRF   x16
0BC4:  MOVLB  0
0BC6:  RCALL  0468
....................             break; 
0BC8:  BRA    0BDE
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0BCA:  MOVFF  41A,33
0BCE:  MOVFF  41B,32
....................             usb_put_0len_0(); 
0BD2:  MOVLB  1
0BD4:  CLRF   x16
0BD6:  MOVLB  0
0BD8:  RCALL  0468
....................             break; 
0BDA:  BRA    0BDE
....................  
....................          default: 
....................             usb_request_stall(); 
0BDC:  RCALL  046E
....................             break; 
0BDE:  MOVLB  4
....................       } 
....................    } 
0BE0:  MOVLB  0
0BE2:  GOTO   0C14 (RETURN)
.................... } 
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
0F54:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0; 
0F56:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0F58:  MOVLW  02
0F5A:  MOVLB  1
0F5C:  MOVWF  x14
0F5E:  MOVLB  0
0F60:  BRA    0EFE
0F62:  MOVFF  01,1F
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
0F66:  MOVF   1F,F
0F68:  BNZ   0F6C
....................    { 
....................       usb_cdc_get_discard(); 
0F6A:  BRA    0F42
....................    } 
0F6C:  GOTO   0F88 (RETURN)
....................    /* 
....................   #if defined(USB_CDC_ISR) 
....................    else 
....................    { 
....................       USB_CDC_ISR(); 
....................    } 
....................   #endif 
....................   */ 
.................... } 
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_tx_buffer(); 
*
107A:  RCALL  1054
107C:  GOTO   10AC (RETURN)
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void usb_cdc_flush_tx_buffer(void)  
.................... { 
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE 
....................    usb_cdc_tx_t n; 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_nextin != 0) 
*
1054:  MOVF   x7B,F
1056:  BZ    1078
....................    { 
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
1058:  MOVLW  02
105A:  MOVLB  1
105C:  MOVWF  x14
105E:  CLRF   x16
1060:  MOVLW  3C
1062:  MOVWF  x15
1064:  CLRF   x18
1066:  MOVFF  7B,117
106A:  MOVLW  02
106C:  MOVWF  x19
106E:  MOVLB  0
1070:  RCALL  0FB6
1072:  MOVF   01,F
1074:  BZ    1078
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
1076:  CLRF   x7B
....................       } 
....................      #else 
....................       n = usb_cdc_put_buffer_nextin; 
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets 
....................          n = USB_CDC_DATA_IN_SIZE-1; 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE)) 
....................       { 
....................          //pull the buffer back 
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n); 
....................          usb_cdc_put_buffer_nextin -= n; 
....................       }       
....................      #endif 
....................    } 
1078:  RETURN 0
.................... } 
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
0382:  MOVLB  1
0384:  CLRF   x15
0386:  CLRF   x14
0388:  MOVLW  25
038A:  MOVWF  x13
038C:  MOVLW  80
038E:  MOVWF  x12
0390:  CLRF   FEA
0392:  MOVLW  2B
0394:  MOVWF  FE9
0396:  MOVLW  01
0398:  MOVWF  FE2
039A:  MOVLW  12
039C:  MOVWF  FE1
039E:  MOVLW  02
03A0:  MOVWF  01
03A2:  MOVFF  FE6,FEE
03A6:  DECFSZ 01,F
03A8:  BRA    03A2
03AA:  CLRF   2D
03AC:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0; 
03AE:  CLRF   x12
03B0:  CLRF   FEA
03B2:  MOVLW  2F
03B4:  MOVWF  FE9
03B6:  MOVLW  01
03B8:  MOVWF  FE2
03BA:  MOVLW  12
03BC:  MOVWF  FE1
03BE:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bParityType = 0; 
03C2:  CLRF   x12
03C4:  CLRF   FEA
03C6:  MOVLW  30
03C8:  MOVWF  FE9
03CA:  MOVLW  01
03CC:  MOVWF  FE2
03CE:  MOVLW  12
03D0:  MOVWF  FE1
03D2:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bDataBits = 8; 
03D6:  MOVLW  08
03D8:  MOVWF  x12
03DA:  CLRF   FEA
03DC:  MOVLW  31
03DE:  MOVWF  FE9
03E0:  MOVLW  01
03E2:  MOVWF  FE2
03E4:  MOVLW  12
03E6:  MOVWF  FE1
03E8:  MOVFF  FE6,FEE
....................    (int8)usb_cdc_carrier = 0; 
03EC:  MOVLB  0
03EE:  CLRF   x7D
....................    usb_cdc_got_set_line_coding = FALSE; 
03F0:  BCF    x7C.0
....................    usb_cdc_break = 0; 
03F2:  CLRF   33
03F4:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0; 
03F6:  CLRF   x7B
....................    usb_cdc_get_buffer_status.got = 0; 
03F8:  BCF    1E.0
....................    __usb_cdc_state = 0; 
03FA:  CLRF   x7E
03FC:  RETURN 0
.................... } 
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
0F42:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0F44:  MOVLW  02
0F46:  MOVLB  1
0F48:  MOVWF  x14
0F4A:  MOVWF  x15
0F4C:  MOVLB  0
0F4E:  RCALL  0C18
0F50:  GOTO   0F6C (RETURN)
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
....................    { 
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif 
....................    } 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
....................    { 
....................       usb_cdc_get_discard(); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0 
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
*
2296:  BCF    xE8.0
2298:  BTFSC  FA0.5
229A:  BSF    xE8.0
229C:  BCF    FA0.5
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer))  
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
229E:  MOVF   x7B,W
22A0:  SUBLW  3E
22A2:  BC    22A8
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
22A4:  MOVLW  3E
22A6:  MOVWF  x7B
....................    } 
....................     
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
22A8:  MOVF   x7B,W
22AA:  INCF   x7B,F
22AC:  CLRF   03
22AE:  ADDLW  3C
22B0:  MOVWF  FE9
22B2:  MOVLW  00
22B4:  ADDWFC 03,W
22B6:  MOVWF  FEA
22B8:  MOVFF  E7,FEF
....................  
....................    __USB_RESTORE_ISR(); 
22BC:  BTFSS  xE8.0
22BE:  BRA    22C2
22C0:  BSF    FA0.5
22C2:  GOTO   22CC (RETURN)
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
22C6:  MOVFF  E6,E7
22CA:  BRA    2296
22CC:  CLRF   16
22CE:  BTFSC  FF2.7
22D0:  BSF    16.7
22D2:  BCF    FF2.7
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................   #if !defined(USB_CDC_DELAYED_FLUSH) 
....................    //if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_tx_buffer(); 
22D4:  CALL   1054
22D8:  BTFSC  16.7
22DA:  BSF    FF2.7
....................    } 
....................   #endif 
22DC:  GOTO   22F0 (RETURN)
....................  
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
22E0:  MOVLW  3F
22E2:  BSF    FD8.0
22E4:  SUBFWB x7B,W
22E6:  BNZ   22EA
....................    { 
....................      #if 0 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_tx_buffer(); 
....................       } 
....................      #endif 
....................      #if defined(USB_ISR_POLLING) 
22E8:  BRA    22E0
....................       usb_task(); 
....................      #endif      
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
22EA:  MOVFF  E5,E6
22EE:  BRA    22C6
22F0:  RETURN 0
.................... } 
....................  
.................... int1 usb_cdc_putd(unsigned char *ptr, unsigned int8 len) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    while(len--) 
....................    { 
....................       c = *ptr++; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_tx_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... {    
....................    unsigned int8 len; 
....................  
....................    len = strlen(ptr); 
....................    
....................    return(usb_cdc_putd(ptr, len)); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... #PRIORITY INT_EXT1,INT_EXT  //interrupcion con prioridad 
.................... #include <medidas.h>   // medir corriente y voltaje 
....................  
....................  
....................  
.................... //funciones dedicadas hacer la lecturas del adc 
.................... float corriente(); 
.................... float voltaje(); 
....................  
.................... float corriente(){ 
*
1E8E:  CLRF   xD9
1E90:  CLRF   xD8
1E92:  CLRF   xDD
1E94:  CLRF   xDC
1E96:  CLRF   xDB
1E98:  CLRF   xDA
1E9A:  CLRF   xE1
1E9C:  CLRF   xE0
1E9E:  CLRF   xDF
1EA0:  CLRF   xDE
1EA2:  CLRF   xE5
1EA4:  CLRF   xE4
1EA6:  CLRF   xE3
1EA8:  CLRF   xE2
....................         
....................     int16 suma = 0; 
....................     float muestras = 0; 
....................     float valor_adc_1 = 0; 
....................     float corriente = 0;  
....................     //disable_interrupts(global); 
....................     setup_adc(ADC_CLOCK_INTERNAL); 
1EAA:  MOVF   FC0,W
1EAC:  ANDLW  C0
1EAE:  IORLW  07
1EB0:  MOVWF  FC0
1EB2:  BSF    FC0.7
1EB4:  BSF    FC2.0
....................     setUP_adc_ports(AN0_TO_AN1); 
1EB6:  MOVF   FC1,W
1EB8:  ANDLW  C0
1EBA:  IORLW  0D
1EBC:  MOVWF  FC1
....................    
....................     float promedio = 0; 
1EBE:  CLRF   xE9
1EC0:  CLRF   xE8
1EC2:  CLRF   xE7
1EC4:  CLRF   xE6
....................     while (suma<=500){ 
1EC6:  MOVF   xD9,W
1EC8:  SUBLW  01
1ECA:  BNC   1FB0
1ECC:  BNZ   1ED4
1ECE:  MOVF   xD8,W
1ED0:  SUBLW  F4
1ED2:  BNC   1FB0
....................       set_adc_channel(0); 
1ED4:  MOVLW  00
1ED6:  MOVWF  01
1ED8:  MOVF   FC2,W
1EDA:  ANDLW  C3
1EDC:  IORWF  01,W
1EDE:  MOVWF  FC2
....................        delay_us(20); 
1EE0:  MOVLW  34
1EE2:  MOVWF  00
1EE4:  DECFSZ 00,F
1EE6:  BRA    1EE4
1EE8:  BRA    1EEA
1EEA:  NOP   
....................        valor_adc_1 = read_adc(); 
1EEC:  BSF    FC2.1
1EEE:  BTFSC  FC2.1
1EF0:  BRA    1EEE
1EF2:  MOVFF  FC4,03
1EF6:  MOVF   FC3,W
1EF8:  CLRF   16
1EFA:  BTFSC  FF2.7
1EFC:  BSF    16.7
1EFE:  BCF    FF2.7
1F00:  MOVLB  1
1F02:  MOVWF  x10
1F04:  MOVFF  FC4,111
1F08:  MOVLB  0
1F0A:  CALL   1232
1F0E:  BTFSC  16.7
1F10:  BSF    FF2.7
1F12:  MOVFF  03,E1
1F16:  MOVFF  02,E0
1F1A:  MOVFF  01,DF
1F1E:  MOVFF  00,DE
....................        corriente = valor_adc_1 * (0.7/1023.0); 
1F22:  MOVFF  E1,ED
1F26:  MOVFF  E0,EC
1F2A:  MOVFF  DF,EB
1F2E:  MOVFF  DE,EA
1F32:  MOVLW  0B
1F34:  MOVWF  xF1
1F36:  MOVLW  60
1F38:  MOVWF  xF0
1F3A:  MOVLW  33
1F3C:  MOVWF  xEF
1F3E:  MOVLW  74
1F40:  MOVWF  xEE
1F42:  RCALL  174C
1F44:  MOVFF  03,E5
1F48:  MOVFF  02,E4
1F4C:  MOVFF  01,E3
1F50:  MOVFF  00,E2
....................        muestras +=  (corriente*100.0); 
1F54:  MOVFF  E5,ED
1F58:  MOVFF  E4,EC
1F5C:  MOVFF  E3,EB
1F60:  MOVFF  E2,EA
1F64:  CLRF   xF1
1F66:  CLRF   xF0
1F68:  MOVLW  48
1F6A:  MOVWF  xEF
1F6C:  MOVLW  85
1F6E:  MOVWF  xEE
1F70:  CALL   174C
1F74:  BCF    FD8.1
1F76:  MOVFF  DD,FF
1F7A:  MOVFF  DC,FE
1F7E:  MOVFF  DB,FD
1F82:  MOVFF  DA,FC
1F86:  MOVFF  03,103
1F8A:  MOVFF  02,102
1F8E:  MOVFF  01,101
1F92:  MOVFF  00,100
1F96:  RCALL  1876
1F98:  MOVFF  03,DD
1F9C:  MOVFF  02,DC
1FA0:  MOVFF  01,DB
1FA4:  MOVFF  00,DA
....................        suma++; 
1FA8:  INCF   xD8,F
1FAA:  BTFSC  FD8.2
1FAC:  INCF   xD9,F
1FAE:  BRA    1EC6
1FB0:  CLRF   16
1FB2:  BTFSC  FF2.7
1FB4:  BSF    16.7
1FB6:  BCF    FF2.7
....................     }  
....................        
....................       promedio = muestras/500; 
1FB8:  MOVFF  DD,117
1FBC:  MOVFF  DC,116
1FC0:  MOVFF  DB,115
1FC4:  MOVFF  DA,114
1FC8:  MOVLB  1
1FCA:  CLRF   x1B
1FCC:  CLRF   x1A
1FCE:  MOVLW  7A
1FD0:  MOVWF  x19
1FD2:  MOVLW  87
1FD4:  MOVWF  x18
1FD6:  MOVLB  0
1FD8:  CALL   1268
1FDC:  BTFSC  16.7
1FDE:  BSF    FF2.7
1FE0:  MOVFF  03,E9
1FE4:  MOVFF  02,E8
1FE8:  MOVFF  01,E7
1FEC:  MOVFF  00,E6
....................       //limpiar variables 
....................        suma = 0; 
1FF0:  CLRF   xD9
1FF2:  CLRF   xD8
....................        muestras = 0; 
1FF4:  CLRF   xDD
1FF6:  CLRF   xDC
1FF8:  CLRF   xDB
1FFA:  CLRF   xDA
....................        valor_adc_1 = 0; 
1FFC:  CLRF   xE1
1FFE:  CLRF   xE0
2000:  CLRF   xDF
2002:  CLRF   xDE
....................       corriente = 0;  
2004:  CLRF   xE5
2006:  CLRF   xE4
2008:  CLRF   xE3
200A:  CLRF   xE2
....................       setup_adc (ADC_OFF); 
200C:  BCF    FC2.0
....................      
....................     enable_interrupts(INT_EXT); 
200E:  BSF    FF2.4
....................     enable_interrupts(INT_EXT1); 
2010:  BSF    FF0.3
....................     enable_interrupts(GLOBAL); 
2012:  MOVLW  C0
2014:  IORWF  FF2,F
....................       return (promedio );      
2016:  MOVFF  E6,00
201A:  MOVFF  E7,01
201E:  MOVFF  E8,02
2022:  MOVFF  E9,03
2026:  RETURN 0
.................... } 
....................  
....................  
.................... float voltaje(){ 
*
2E84:  CLRF   xDA
2E86:  CLRF   xDB
....................  
....................    unsigned int lectura_1,lectura_2; 
....................    unsigned int mayor= 0,mayor1 = 0; 
....................    const float res1=4700; 
....................    const float res2=1000; 
....................    float voltaje; 
....................    char cont; 
....................    set_adc_channel(1); 
2E88:  MOVLW  04
2E8A:  MOVWF  01
2E8C:  MOVF   FC2,W
2E8E:  ANDLW  C3
2E90:  IORWF  01,W
2E92:  MOVWF  FC2
....................   for (cont=0;cont<250;cont++) 
2E94:  CLRF   xE0
2E96:  MOVF   xE0,W
2E98:  SUBLW  F9
2E9A:  BNC   2EE2
....................   { 
....................    lectura_1=read_adc(); //realiza primeralectura; 
2E9C:  BSF    FC2.1
2E9E:  BTFSC  FC2.1
2EA0:  BRA    2E9E
2EA2:  MOVFF  FC3,D8
....................    delay_us(10); 
2EA6:  MOVLW  1A
2EA8:  MOVWF  00
2EAA:  DECFSZ 00,F
2EAC:  BRA    2EAA
2EAE:  NOP   
....................    lectura_2=read_adc(); //realiza segundalectura; 
2EB0:  BSF    FC2.1
2EB2:  BTFSC  FC2.1
2EB4:  BRA    2EB2
2EB6:  MOVFF  FC3,D9
....................    delay_us(10); 
2EBA:  MOVLW  1A
2EBC:  MOVWF  00
2EBE:  DECFSZ 00,F
2EC0:  BRA    2EBE
2EC2:  NOP   
....................    if (lectura_2>lectura_1)  mayor=lectura_1; 
2EC4:  MOVF   xD9,W
2EC6:  SUBWF  xD8,W
2EC8:  BC    2ED0
2ECA:  MOVFF  D8,DA
2ECE:  BRA    2ED4
....................     else mayor=lectura_2; 
2ED0:  MOVFF  D9,DA
....................    if (mayor>mayor1) mayor1=mayor; 
2ED4:  MOVF   xDA,W
2ED6:  SUBWF  xDB,W
2ED8:  BTFSS  FD8.0
2EDA:  MOVFF  DA,DB
2EDE:  INCF   xE0,F
2EE0:  BRA    2E96
2EE2:  CLRF   16
2EE4:  BTFSC  FF2.7
2EE6:  BSF    16.7
2EE8:  BCF    FF2.7
....................    } 
....................    voltaje=mayor1*1.1/1023;          //calcula el voltaje 
2EEA:  MOVLB  1
2EEC:  CLRF   x11
2EEE:  MOVFF  DB,110
2EF2:  MOVLB  0
2EF4:  CALL   1232
2EF8:  BTFSC  16.7
2EFA:  BSF    FF2.7
2EFC:  MOVFF  03,ED
2F00:  MOVFF  02,EC
2F04:  MOVFF  01,EB
2F08:  MOVFF  00,EA
2F0C:  MOVLW  CD
2F0E:  MOVWF  xF1
2F10:  MOVLW  CC
2F12:  MOVWF  xF0
2F14:  MOVLW  0C
2F16:  MOVWF  xEF
2F18:  MOVLW  7F
2F1A:  MOVWF  xEE
2F1C:  CALL   174C
2F20:  MOVFF  03,E4
2F24:  MOVFF  02,E3
2F28:  MOVFF  01,E2
2F2C:  MOVFF  00,E1
2F30:  CLRF   16
2F32:  BTFSC  FF2.7
2F34:  BSF    16.7
2F36:  BCF    FF2.7
2F38:  MOVFF  03,117
2F3C:  MOVFF  02,116
2F40:  MOVFF  01,115
2F44:  MOVFF  00,114
2F48:  MOVLB  1
2F4A:  CLRF   x1B
2F4C:  MOVLW  C0
2F4E:  MOVWF  x1A
2F50:  MOVLW  7F
2F52:  MOVWF  x19
2F54:  MOVLW  88
2F56:  MOVWF  x18
2F58:  MOVLB  0
2F5A:  CALL   1268
2F5E:  BTFSC  16.7
2F60:  BSF    FF2.7
2F62:  MOVFF  03,DF
2F66:  MOVFF  02,DE
2F6A:  MOVFF  01,DD
2F6E:  MOVFF  00,DC
....................  
....................    voltaje=voltaje*((res1+res2)/res2);  //aplica el divisor resistivo 
2F72:  MOVFF  DF,ED
2F76:  MOVFF  DE,EC
2F7A:  MOVFF  DD,EB
2F7E:  MOVFF  DC,EA
2F82:  MOVLW  66
2F84:  MOVWF  xF1
2F86:  MOVWF  xF0
2F88:  MOVLW  36
2F8A:  MOVWF  xEF
2F8C:  MOVLW  81
2F8E:  MOVWF  xEE
2F90:  CALL   174C
2F94:  MOVFF  03,DF
2F98:  MOVFF  02,DE
2F9C:  MOVFF  01,DD
2FA0:  MOVFF  00,DC
....................  
....................    voltaje=voltaje;              //suma caida en el puente rectificador 
....................    voltaje=(voltaje+1.4)/1.4142;   // saca RMS 
2FA4:  BCF    FD8.1
2FA6:  MOVFF  DF,FF
2FAA:  MOVFF  DE,FE
2FAE:  MOVFF  DD,FD
2FB2:  MOVFF  DC,FC
2FB6:  MOVLW  33
2FB8:  MOVLB  1
2FBA:  MOVWF  x03
2FBC:  MOVWF  x02
2FBE:  MOVWF  x01
2FC0:  MOVLW  7F
2FC2:  MOVWF  x00
2FC4:  MOVLB  0
2FC6:  CALL   1876
2FCA:  MOVFF  03,E4
2FCE:  MOVFF  02,E3
2FD2:  MOVFF  01,E2
2FD6:  MOVFF  00,E1
2FDA:  CLRF   16
2FDC:  BTFSC  FF2.7
2FDE:  BSF    16.7
2FE0:  BCF    FF2.7
2FE2:  MOVFF  03,117
2FE6:  MOVFF  02,116
2FEA:  MOVFF  01,115
2FEE:  MOVFF  00,114
2FF2:  MOVLW  81
2FF4:  MOVLB  1
2FF6:  MOVWF  x1B
2FF8:  MOVLW  04
2FFA:  MOVWF  x1A
2FFC:  MOVLW  35
2FFE:  MOVWF  x19
3000:  MOVLW  7F
3002:  MOVWF  x18
3004:  MOVLB  0
3006:  CALL   1268
300A:  BTFSC  16.7
300C:  BSF    FF2.7
300E:  MOVFF  03,DF
3012:  MOVFF  02,DE
3016:  MOVFF  01,DD
301A:  MOVFF  00,DC
....................    return  voltaje*220; 
301E:  MOVFF  DF,ED
3022:  MOVFF  DE,EC
3026:  MOVFF  DD,EB
302A:  MOVFF  DC,EA
302E:  CLRF   xF1
3030:  CLRF   xF0
3032:  MOVLW  5C
3034:  MOVWF  xEF
3036:  MOVLW  86
3038:  MOVWF  xEE
303A:  CALL   174C
303E:  GOTO   3360 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................                                    
.................... #define LCD_RS_PIN      PIN_D1                                    
.................... #define LCD_RW_PIN      PIN_D2 
.................... #define LCD_ENABLE_PIN  PIN_D3   
.................... #define LCD_DATA4       PIN_D4                                    
.................... #define LCD_DATA5       PIN_D5                                   
.................... #define LCD_DATA6       PIN_D6                                 
.................... #define LCD_DATA7       PIN_D7  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
1554:  BSF    F95.4
....................    output_float(LCD_DATA5); 
1556:  BSF    F95.5
....................    output_float(LCD_DATA6); 
1558:  BSF    F95.6
....................    output_float(LCD_DATA7); 
155A:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
155C:  BSF    F8C.2
155E:  BCF    F95.2
....................    delay_cycles(1); 
1560:  NOP   
....................    lcd_output_enable(1); 
1562:  BSF    F8C.3
1564:  BCF    F95.3
....................    delay_cycles(1); 
1566:  NOP   
....................    high = lcd_read_nibble(); 
1568:  RCALL  1502
156A:  MOVFF  01,ED
....................        
....................    lcd_output_enable(0); 
156E:  BCF    F8C.3
1570:  BCF    F95.3
....................    delay_cycles(1); 
1572:  NOP   
....................    lcd_output_enable(1); 
1574:  BSF    F8C.3
1576:  BCF    F95.3
....................    delay_us(1); 
1578:  MOVLW  02
157A:  MOVWF  00
157C:  DECFSZ 00,F
157E:  BRA    157C
1580:  NOP   
....................    low = lcd_read_nibble(); 
1582:  RCALL  1502
1584:  MOVFF  01,EC
....................        
....................    lcd_output_enable(0); 
1588:  BCF    F8C.3
158A:  BCF    F95.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
158C:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
158E:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
1590:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
1592:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
1594:  SWAPF  xED,W
1596:  MOVWF  00
1598:  MOVLW  F0
159A:  ANDWF  00,F
159C:  MOVF   00,W
159E:  IORWF  xEC,W
15A0:  MOVWF  01
15A2:  GOTO   15B2 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
1502:  CLRF   xEE
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
1504:  BSF    F95.4
1506:  MOVLW  00
1508:  BTFSC  F83.4
150A:  MOVLW  01
150C:  IORWF  xEE,F
....................    n |= input(LCD_DATA5) << 1; 
150E:  BSF    F95.5
1510:  MOVLW  00
1512:  BTFSC  F83.5
1514:  MOVLW  01
1516:  MOVWF  00
1518:  BCF    FD8.0
151A:  RLCF   00,F
151C:  MOVF   00,W
151E:  IORWF  xEE,F
....................    n |= input(LCD_DATA6) << 2; 
1520:  BSF    F95.6
1522:  MOVLW  00
1524:  BTFSC  F83.6
1526:  MOVLW  01
1528:  MOVWF  00
152A:  RLCF   00,F
152C:  RLCF   00,F
152E:  MOVLW  FC
1530:  ANDWF  00,F
1532:  MOVF   00,W
1534:  IORWF  xEE,F
....................    n |= input(LCD_DATA7) << 3; 
1536:  BSF    F95.7
1538:  MOVLW  00
153A:  BTFSC  F83.7
153C:  MOVLW  01
153E:  MOVWF  00
1540:  RLCF   00,F
1542:  RLCF   00,F
1544:  RLCF   00,F
1546:  MOVLW  F8
1548:  ANDWF  00,F
154A:  MOVF   00,W
154C:  IORWF  xEE,F
....................     
....................    return(n); 
154E:  MOVFF  EE,01
....................   #else 
1552:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
14BA:  BTFSC  xED.0
14BC:  BRA    14C2
14BE:  BCF    F8C.4
14C0:  BRA    14C4
14C2:  BSF    F8C.4
14C4:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
14C6:  BTFSC  xED.1
14C8:  BRA    14CE
14CA:  BCF    F8C.5
14CC:  BRA    14D0
14CE:  BSF    F8C.5
14D0:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
14D2:  BTFSC  xED.2
14D4:  BRA    14DA
14D6:  BCF    F8C.6
14D8:  BRA    14DC
14DA:  BSF    F8C.6
14DC:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
14DE:  BTFSC  xED.3
14E0:  BRA    14E6
14E2:  BCF    F8C.7
14E4:  BRA    14E8
14E6:  BSF    F8C.7
14E8:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
14EA:  NOP   
....................    lcd_output_enable(1); 
14EC:  BSF    F8C.3
14EE:  BCF    F95.3
....................    delay_us(2); 
14F0:  MOVLW  04
14F2:  MOVWF  00
14F4:  DECFSZ 00,F
14F6:  BRA    14F4
14F8:  BRA    14FA
14FA:  NOP   
....................    lcd_output_enable(0); 
14FC:  BCF    F8C.3
14FE:  BCF    F95.3
1500:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
15A6:  BCF    F95.3
....................    lcd_rs_tris(); 
15A8:  BCF    F95.1
....................    lcd_rw_tris(); 
15AA:  BCF    F95.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
15AC:  BCF    F8C.1
15AE:  BCF    F95.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
15B0:  BRA    1554
15B2:  MOVFF  01,EC
15B6:  BTFSC  01.7
15B8:  BRA    15B0
....................    lcd_output_rs(address); 
15BA:  MOVF   xEA,F
15BC:  BNZ   15C2
15BE:  BCF    F8C.1
15C0:  BRA    15C4
15C2:  BSF    F8C.1
15C4:  BCF    F95.1
....................    delay_cycles(1); 
15C6:  NOP   
....................    lcd_output_rw(0); 
15C8:  BCF    F8C.2
15CA:  BCF    F95.2
....................    delay_cycles(1); 
15CC:  NOP   
....................    lcd_output_enable(0); 
15CE:  BCF    F8C.3
15D0:  BCF    F95.3
....................    lcd_send_nibble(n >> 4); 
15D2:  SWAPF  xEB,W
15D4:  MOVWF  xEC
15D6:  MOVLW  0F
15D8:  ANDWF  xEC,F
15DA:  MOVFF  EC,ED
15DE:  RCALL  14BA
....................    lcd_send_nibble(n & 0xf); 
15E0:  MOVF   xEB,W
15E2:  ANDLW  0F
15E4:  MOVWF  xEC
15E6:  MOVWF  xED
15E8:  RCALL  14BA
15EA:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
15EC:  MOVLW  28
15EE:  MOVWF  xD9
15F0:  MOVLW  0C
15F2:  MOVWF  xDA
15F4:  MOVLW  01
15F6:  MOVWF  xDB
15F8:  MOVLW  06
15FA:  MOVWF  xDC
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
15FC:  BCF    F8C.3
15FE:  BCF    F95.3
....................    lcd_output_rs(0); 
1600:  BCF    F8C.1
1602:  BCF    F95.1
....................    lcd_output_rw(0); 
1604:  BCF    F8C.2
1606:  BCF    F95.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
1608:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
160A:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
160C:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
160E:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
1610:  BCF    F95.3
....................    lcd_rs_tris(); 
1612:  BCF    F95.1
....................    lcd_rw_tris(); 
1614:  BCF    F95.2
....................  #endif 
....................      
....................    delay_ms(15); 
1616:  MOVLW  0F
1618:  MOVWF  xE6
161A:  RCALL  1494
....................    for(i=1;i<=3;++i) 
161C:  MOVLW  01
161E:  MOVWF  xD8
1620:  MOVF   xD8,W
1622:  SUBLW  03
1624:  BNC   1636
....................    { 
....................        lcd_send_nibble(3); 
1626:  MOVLW  03
1628:  MOVWF  xED
162A:  RCALL  14BA
....................        delay_ms(5); 
162C:  MOVLW  05
162E:  MOVWF  xE6
1630:  RCALL  1494
1632:  INCF   xD8,F
1634:  BRA    1620
....................    } 
....................     
....................    lcd_send_nibble(2); 
1636:  MOVLW  02
1638:  MOVWF  xED
163A:  RCALL  14BA
....................    delay_ms(5); 
163C:  MOVLW  05
163E:  MOVWF  xE6
1640:  RCALL  1494
....................    for(i=0;i<=3;++i) 
1642:  CLRF   xD8
1644:  MOVF   xD8,W
1646:  SUBLW  03
1648:  BNC   1668
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
164A:  CLRF   03
164C:  MOVF   xD8,W
164E:  ADDLW  D9
1650:  MOVWF  FE9
1652:  MOVLW  00
1654:  ADDWFC 03,W
1656:  MOVWF  FEA
1658:  MOVFF  FEF,DD
165C:  CLRF   xEA
165E:  MOVFF  DD,EB
1662:  RCALL  15A6
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
1664:  INCF   xD8,F
1666:  BRA    1644
1668:  GOTO   3114 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
166C:  DECFSZ xE7,W
166E:  BRA    1672
1670:  BRA    1678
....................       address=LCD_LINE_TWO; 
1672:  MOVLW  40
1674:  MOVWF  xE8
1676:  BRA    167A
....................    else 
....................       address=0; 
1678:  CLRF   xE8
....................       
....................    address+=x-1; 
167A:  MOVLW  01
167C:  SUBWF  xE6,W
167E:  ADDWF  xE8,F
....................    lcd_send_byte(0,0x80|address); 
1680:  MOVF   xE8,W
1682:  IORLW  80
1684:  MOVWF  xE9
1686:  CLRF   xEA
1688:  MOVWF  xEB
168A:  RCALL  15A6
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
168C:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
168E:  MOVF   xE5,W
1690:  XORLW  07
1692:  BZ    16A2
1694:  XORLW  0B
1696:  BZ    16AC
1698:  XORLW  06
169A:  BZ    16BC
169C:  XORLW  02
169E:  BZ    16C8
16A0:  BRA    16D2
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
16A2:  MOVLW  01
16A4:  MOVWF  xE6
16A6:  MOVWF  xE7
16A8:  RCALL  166C
16AA:  BRA    16DC
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
16AC:  CLRF   xEA
16AE:  MOVLW  01
16B0:  MOVWF  xEB
16B2:  RCALL  15A6
....................                      delay_ms(2); 
16B4:  MOVLW  02
16B6:  MOVWF  xE6
16B8:  RCALL  1494
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
16BA:  BRA    16DC
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
16BC:  MOVLW  01
16BE:  MOVWF  xE6
16C0:  MOVLW  02
16C2:  MOVWF  xE7
16C4:  RCALL  166C
16C6:  BRA    16DC
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
16C8:  CLRF   xEA
16CA:  MOVLW  10
16CC:  MOVWF  xEB
16CE:  RCALL  15A6
16D0:  BRA    16DC
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
16D2:  MOVLW  01
16D4:  MOVWF  xEA
16D6:  MOVFF  E5,EB
16DA:  RCALL  15A6
....................      #endif 
....................    } 
16DC:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define tau 6.28318     //valor de 2pi 
.................... #define REINICIA_TIMER 0 
.................... #define freq 50.0   //frecucnia de de red 
.................... float t1=0;   //valore del timer obtenidos por la interrupcion  
.................... int1 cambio= 0;   //flag que indica que se ah reiniciado el timer 
.................... float  cos_fi =0 ; 
.................... float indice=0;//sgun el indice elije un valor dentro del stich case 
.................... float voltaje_rms=0; 
.................... // 
....................  
.................... int get_indice(float t1); 
.................... float roundDecimal(float num); 
.................... float corriente_rms =0; 
.................... void valores(void);  //contine el switch case con los valores calculador de cos_fi 
.................... #include <fusy.h> 
....................  
....................  
.................... //directivas fusy 
.................... #define infi 10000.0  
.................... #define quitar  -1 
.................... #define mantener 0 
.................... #define anadir +1 
....................  
....................  
.................... //variables logica difusa 
.................... float regDifusas[3][3] = {{anadir  ,anadir ,anadir},     
....................                           {anadir   ,mantener  ,quitar},   
....................                           {mantener  ,mantener  ,quitar}};  
....................                            
.................... float FPActual = cos_fi;  // Ajusta este valor segn tu aplicacin 
.................... float uError[3]; 
.................... //float uError[3],uDerror[3]; 
.................... float sumaPOND,sumaPERT; 
.................... int p,q; 
.................... float salida; 
....................  
.................... //Operaciones Funciones de membrecias(logica difusa) 
.................... void difuso(void); 
.................... float triang(float x, float a, float m, float b); 
.................... float trapz (float x,float a,float b,float c,float d); 
.................... float fuzzyAND(float r,float s); 
....................  
....................  
.................... void difuso() { 
....................    //Universo Difuso = Error (FPActual) 
....................   float uError[3]; 
....................   uError[0] = trapz(FPActual, -infi, -infi, 0.5, 0.9);     // FPActual=Bajo 
*
2952:  MOVFF  BC,E7
2956:  MOVFF  BB,E6
295A:  MOVFF  BA,E5
295E:  MOVFF  B9,E4
2962:  CLRF   xEB
2964:  MOVLW  40
2966:  MOVWF  xEA
2968:  MOVLW  9C
296A:  MOVWF  xE9
296C:  MOVLW  8C
296E:  MOVWF  xE8
2970:  CLRF   xEF
2972:  MOVLW  40
2974:  MOVWF  xEE
2976:  MOVLW  9C
2978:  MOVWF  xED
297A:  MOVLW  8C
297C:  MOVWF  xEC
297E:  CLRF   xF3
2980:  CLRF   xF2
2982:  CLRF   xF1
2984:  MOVLW  7E
2986:  MOVWF  xF0
2988:  MOVLW  66
298A:  MOVWF  xF7
298C:  MOVWF  xF6
298E:  MOVWF  xF5
2990:  MOVLW  7E
2992:  MOVWF  xF4
2994:  RCALL  248A
2996:  MOVFF  03,DB
299A:  MOVFF  02,DA
299E:  MOVFF  01,D9
29A2:  MOVFF  00,D8
....................   uError[1] = triang(FPActual, 0.8, 0.93, 0.96);            // FPActual=Medio 
29A6:  MOVFF  BC,E7
29AA:  MOVFF  BB,E6
29AE:  MOVFF  BA,E5
29B2:  MOVFF  B9,E4
29B6:  MOVLW  CD
29B8:  MOVWF  xEB
29BA:  MOVLW  CC
29BC:  MOVWF  xEA
29BE:  MOVLW  4C
29C0:  MOVWF  xE9
29C2:  MOVLW  7E
29C4:  MOVWF  xE8
29C6:  MOVLW  7B
29C8:  MOVWF  xEF
29CA:  MOVLW  14
29CC:  MOVWF  xEE
29CE:  MOVLW  6E
29D0:  MOVWF  xED
29D2:  MOVLW  7E
29D4:  MOVWF  xEC
29D6:  MOVLW  8F
29D8:  MOVWF  xF3
29DA:  MOVLW  C2
29DC:  MOVWF  xF2
29DE:  MOVLW  75
29E0:  MOVWF  xF1
29E2:  MOVLW  7E
29E4:  MOVWF  xF0
29E6:  BRA    26F4
29E8:  MOVFF  03,DF
29EC:  MOVFF  02,DE
29F0:  MOVFF  01,DD
29F4:  MOVFF  00,DC
....................   uError[2] = trapz(FPActual, 0.95, 0.97, infi, infi);       // FPActual=Alto 
29F8:  MOVFF  BC,E7
29FC:  MOVFF  BB,E6
2A00:  MOVFF  BA,E5
2A04:  MOVFF  B9,E4
2A08:  MOVLW  33
2A0A:  MOVWF  xEB
2A0C:  MOVWF  xEA
2A0E:  MOVLW  73
2A10:  MOVWF  xE9
2A12:  MOVLW  7E
2A14:  MOVWF  xE8
2A16:  MOVLW  EC
2A18:  MOVWF  xEF
2A1A:  MOVLW  51
2A1C:  MOVWF  xEE
2A1E:  MOVLW  78
2A20:  MOVWF  xED
2A22:  MOVLW  7E
2A24:  MOVWF  xEC
2A26:  CLRF   xF3
2A28:  MOVLW  40
2A2A:  MOVWF  xF2
2A2C:  MOVLW  1C
2A2E:  MOVWF  xF1
2A30:  MOVLW  8C
2A32:  MOVWF  xF0
2A34:  CLRF   xF7
2A36:  MOVLW  40
2A38:  MOVWF  xF6
2A3A:  MOVLW  1C
2A3C:  MOVWF  xF5
2A3E:  MOVLW  8C
2A40:  MOVWF  xF4
2A42:  RCALL  248A
2A44:  MOVFF  03,E3
2A48:  MOVFF  02,E2
2A4C:  MOVFF  01,E1
2A50:  MOVFF  00,E0
....................   //Universo DerivadaError Desfase 
....................    
....................   // Inferencia 
....................   sumaPOND = 0.0; 
2A54:  CLRF   xCC
2A56:  CLRF   xCB
2A58:  CLRF   xCA
2A5A:  CLRF   xC9
....................   sumaPERT = 0.0; 
2A5C:  CLRF   xD0
2A5E:  CLRF   xCF
2A60:  CLRF   xCE
2A62:  CLRF   xCD
....................  
....................   for (p = 0; p < 3; p++) { 
2A64:  CLRF   xD1
2A66:  MOVF   xD1,W
2A68:  SUBLW  02
2A6A:  BTFSS  FD8.0
2A6C:  BRA    2C32
....................     for (q = 0; q < 3; q++) { 
2A6E:  CLRF   xD2
2A70:  MOVF   xD2,W
2A72:  SUBLW  02
2A74:  BTFSS  FD8.0
2A76:  BRA    2C2E
....................       sumaPOND += regDifusas[p][q] * fuzzyAND(uError[p], uError[q]); 
2A78:  MOVF   xD1,W
2A7A:  MULLW  0C
2A7C:  MOVF   FF3,W
2A7E:  CLRF   xE5
2A80:  MOVWF  xE4
2A82:  MOVF   xD2,W
2A84:  MULLW  04
2A86:  MOVF   FF3,W
2A88:  CLRF   03
2A8A:  ADDWF  xE4,W
2A8C:  MOVWF  01
2A8E:  MOVF   xE5,W
2A90:  ADDWFC 03,F
2A92:  MOVF   01,W
2A94:  ADDLW  95
2A96:  MOVWF  FE9
2A98:  MOVLW  00
2A9A:  ADDWFC 03,W
2A9C:  MOVWF  FEA
2A9E:  MOVFF  FEF,E4
2AA2:  MOVFF  FEC,E5
2AA6:  MOVFF  FEC,E6
2AAA:  MOVFF  FEC,E7
2AAE:  MOVF   xD1,W
2AB0:  MULLW  04
2AB2:  MOVF   FF3,W
2AB4:  CLRF   03
2AB6:  ADDLW  D8
2AB8:  MOVWF  FE9
2ABA:  MOVLW  00
2ABC:  ADDWFC 03,W
2ABE:  MOVWF  FEA
2AC0:  MOVFF  FEF,E8
2AC4:  MOVFF  FEC,E9
2AC8:  MOVFF  FEC,EA
2ACC:  MOVFF  FEC,EB
2AD0:  MOVF   xD2,W
2AD2:  MULLW  04
2AD4:  MOVF   FF3,W
2AD6:  CLRF   03
2AD8:  ADDLW  D8
2ADA:  MOVWF  FE9
2ADC:  MOVLW  00
2ADE:  ADDWFC 03,W
2AE0:  MOVWF  FEA
2AE2:  MOVFF  FEF,EC
2AE6:  MOVFF  FEC,ED
2AEA:  MOVFF  FEC,EE
2AEE:  MOVFF  FEC,EF
2AF2:  MOVFF  EB,F3
2AF6:  MOVFF  EA,F2
2AFA:  MOVFF  E9,F1
2AFE:  MOVFF  E8,F0
2B02:  MOVFF  EF,F7
2B06:  MOVFF  EE,F6
2B0A:  MOVFF  ED,F5
2B0E:  MOVFF  EC,F4
2B12:  RCALL  2906
2B14:  MOVFF  E7,ED
2B18:  MOVFF  E6,EC
2B1C:  MOVFF  E5,EB
2B20:  MOVFF  E4,EA
2B24:  MOVFF  03,F1
2B28:  MOVFF  02,F0
2B2C:  MOVFF  01,EF
2B30:  MOVFF  00,EE
2B34:  CALL   174C
2B38:  MOVFF  FEA,E5
2B3C:  MOVFF  FE9,E4
2B40:  BCF    FD8.1
2B42:  MOVFF  CC,FF
2B46:  MOVFF  CB,FE
2B4A:  MOVFF  CA,FD
2B4E:  MOVFF  C9,FC
2B52:  MOVFF  03,103
2B56:  MOVFF  02,102
2B5A:  MOVFF  01,101
2B5E:  MOVFF  00,100
2B62:  CALL   1876
2B66:  MOVFF  E5,FEA
2B6A:  MOVFF  E4,FE9
2B6E:  MOVFF  03,CC
2B72:  MOVFF  02,CB
2B76:  MOVFF  01,CA
2B7A:  MOVFF  00,C9
....................       sumaPERT += fuzzyAND(uError[p], uError[q]); 
2B7E:  MOVF   xD1,W
2B80:  MULLW  04
2B82:  MOVF   FF3,W
2B84:  CLRF   03
2B86:  ADDLW  D8
2B88:  MOVWF  FE9
2B8A:  MOVLW  00
2B8C:  ADDWFC 03,W
2B8E:  MOVWF  FEA
2B90:  MOVFF  FEF,E4
2B94:  MOVFF  FEC,E5
2B98:  MOVFF  FEC,E6
2B9C:  MOVFF  FEC,E7
2BA0:  MOVF   xD2,W
2BA2:  MULLW  04
2BA4:  MOVF   FF3,W
2BA6:  CLRF   03
2BA8:  ADDLW  D8
2BAA:  MOVWF  FE9
2BAC:  MOVLW  00
2BAE:  ADDWFC 03,W
2BB0:  MOVWF  FEA
2BB2:  MOVFF  FEF,E8
2BB6:  MOVFF  FEC,E9
2BBA:  MOVFF  FEC,EA
2BBE:  MOVFF  FEC,EB
2BC2:  MOVFF  E7,F3
2BC6:  MOVFF  E6,F2
2BCA:  MOVFF  E5,F1
2BCE:  MOVFF  E4,F0
2BD2:  MOVFF  EB,F7
2BD6:  MOVFF  EA,F6
2BDA:  MOVFF  E9,F5
2BDE:  MOVFF  E8,F4
2BE2:  RCALL  2906
2BE4:  MOVFF  FEA,E5
2BE8:  MOVFF  FE9,E4
2BEC:  BCF    FD8.1
2BEE:  MOVFF  D0,FF
2BF2:  MOVFF  CF,FE
2BF6:  MOVFF  CE,FD
2BFA:  MOVFF  CD,FC
2BFE:  MOVFF  03,103
2C02:  MOVFF  02,102
2C06:  MOVFF  01,101
2C0A:  MOVFF  00,100
2C0E:  CALL   1876
2C12:  MOVFF  E5,FEA
2C16:  MOVFF  E4,FE9
2C1A:  MOVFF  03,D0
2C1E:  MOVFF  02,CF
2C22:  MOVFF  01,CE
2C26:  MOVFF  00,CD
2C2A:  INCF   xD2,F
2C2C:  BRA    2A70
....................     } 
2C2E:  INCF   xD1,F
2C30:  BRA    2A66
....................   } 
....................  
....................   if (sumaPERT == 0.0) { 
2C32:  MOVFF  D0,FB
2C36:  MOVFF  CF,FA
2C3A:  MOVFF  CE,F9
2C3E:  MOVFF  CD,F8
2C42:  CLRF   xFF
2C44:  CLRF   xFE
2C46:  CLRF   xFD
2C48:  CLRF   xFC
2C4A:  CALL   1AF0
2C4E:  BNZ   2C5A
....................     salida = 0; 
2C50:  CLRF   xD6
2C52:  CLRF   xD5
2C54:  CLRF   xD4
2C56:  CLRF   xD3
....................   } else { 
2C58:  BRA    2C9A
2C5A:  CLRF   16
2C5C:  BTFSC  FF2.7
2C5E:  BSF    16.7
2C60:  BCF    FF2.7
....................     salida = sumaPOND / sumaPERT; 
2C62:  MOVFF  CC,117
2C66:  MOVFF  CB,116
2C6A:  MOVFF  CA,115
2C6E:  MOVFF  C9,114
2C72:  MOVFF  D0,11B
2C76:  MOVFF  CF,11A
2C7A:  MOVFF  CE,119
2C7E:  MOVFF  CD,118
2C82:  CALL   1268
2C86:  BTFSC  16.7
2C88:  BSF    FF2.7
2C8A:  MOVFF  03,D6
2C8E:  MOVFF  02,D5
2C92:  MOVFF  01,D4
2C96:  MOVFF  00,D3
....................   } 
....................  
....................   // Ajustar el resultado a la operacin que desees realizar (aadir, mantener, quitar condensadores) 
....................   if (salida > 0) { 
2C9A:  CLRF   xFB
2C9C:  CLRF   xFA
2C9E:  CLRF   xF9
2CA0:  CLRF   xF8
2CA2:  MOVFF  D6,FF
2CA6:  MOVFF  D5,FE
2CAA:  MOVFF  D4,FD
2CAE:  MOVFF  D3,FC
2CB2:  CALL   1AF0
2CB6:  BNC   2D6C
....................       output_high(PIN_B5); 
2CB8:  BCF    F93.5
2CBA:  BSF    F8A.5
....................       delay_ms(500); // Ajusta el retardo segn tus necesidades 
2CBC:  MOVLW  02
2CBE:  MOVWF  xE4
2CC0:  MOVLW  FA
2CC2:  MOVWF  xE6
2CC4:  CALL   1494
2CC8:  DECFSZ xE4,F
2CCA:  BRA    2CC0
....................       if (cos_fi < 0.97) { 
2CCC:  MOVFF  88,FB
2CD0:  MOVFF  87,FA
2CD4:  MOVFF  86,F9
2CD8:  MOVFF  85,F8
2CDC:  MOVLW  EC
2CDE:  MOVWF  xFF
2CE0:  MOVLW  51
2CE2:  MOVWF  xFE
2CE4:  MOVLW  78
2CE6:  MOVWF  xFD
2CE8:  MOVLW  7E
2CEA:  MOVWF  xFC
2CEC:  CALL   1AF0
2CF0:  BNC   2D06
....................          output_high(PIN_B4); 
2CF2:  BCF    F93.4
2CF4:  BSF    F8A.4
....................          delay_ms(500); 
2CF6:  MOVLW  02
2CF8:  MOVWF  xE4
2CFA:  MOVLW  FA
2CFC:  MOVWF  xE6
2CFE:  CALL   1494
2D02:  DECFSZ xE4,F
2D04:  BRA    2CFA
....................       } 
....................       if (cos_fi< 0.97) { 
2D06:  MOVFF  88,FB
2D0A:  MOVFF  87,FA
2D0E:  MOVFF  86,F9
2D12:  MOVFF  85,F8
2D16:  MOVLW  EC
2D18:  MOVWF  xFF
2D1A:  MOVLW  51
2D1C:  MOVWF  xFE
2D1E:  MOVLW  78
2D20:  MOVWF  xFD
2D22:  MOVLW  7E
2D24:  MOVWF  xFC
2D26:  CALL   1AF0
2D2A:  BNC   2D40
....................          output_high(PIN_B3); 
2D2C:  BCF    F93.3
2D2E:  BSF    F8A.3
....................          delay_ms(500); 
2D30:  MOVLW  02
2D32:  MOVWF  xE4
2D34:  MOVLW  FA
2D36:  MOVWF  xE6
2D38:  CALL   1494
2D3C:  DECFSZ xE4,F
2D3E:  BRA    2D34
....................       } 
....................       if (cos_fi< 0.97) { 
2D40:  MOVFF  88,FB
2D44:  MOVFF  87,FA
2D48:  MOVFF  86,F9
2D4C:  MOVFF  85,F8
2D50:  MOVLW  EC
2D52:  MOVWF  xFF
2D54:  MOVLW  51
2D56:  MOVWF  xFE
2D58:  MOVLW  78
2D5A:  MOVWF  xFD
2D5C:  MOVLW  7E
2D5E:  MOVWF  xFC
2D60:  CALL   1AF0
2D64:  BNC   2D6A
....................          output_high(PIN_B2); 
2D66:  BCF    F93.2
2D68:  BSF    F8A.2
....................       } 
....................     // Realiza las operaciones necesarias para la accin de "aadir" 
....................   } else if (salida == 0) { 
2D6A:  BRA    2E80
2D6C:  MOVFF  D6,FB
2D70:  MOVFF  D5,FA
2D74:  MOVFF  D4,F9
2D78:  MOVFF  D3,F8
2D7C:  CLRF   xFF
2D7E:  CLRF   xFE
2D80:  CLRF   xFD
2D82:  CLRF   xFC
2D84:  CALL   1AF0
2D88:  BNZ   2D8C
....................     // Mantener condensadores 
....................     // No hacer nada ni activar nada 
....................   } else { 
2D8A:  BRA    2E80
....................     output_low(PIN_B5); 
2D8C:  BCF    F93.5
2D8E:  BCF    F8A.5
....................       delay_ms(500); // Ajusta el retardo segn tus necesidades 
2D90:  MOVLW  02
2D92:  MOVWF  xE4
2D94:  MOVLW  FA
2D96:  MOVWF  xE6
2D98:  CALL   1494
2D9C:  DECFSZ xE4,F
2D9E:  BRA    2D94
....................       if (cos_fi >= 0.97) { 
2DA0:  MOVLW  EC
2DA2:  MOVWF  xFB
2DA4:  MOVLW  51
2DA6:  MOVWF  xFA
2DA8:  MOVLW  78
2DAA:  MOVWF  xF9
2DAC:  MOVLW  7E
2DAE:  MOVWF  xF8
2DB0:  MOVFF  88,FF
2DB4:  MOVFF  87,FE
2DB8:  MOVFF  86,FD
2DBC:  MOVFF  85,FC
2DC0:  CALL   1AF0
2DC4:  BC    2DC8
2DC6:  BNZ   2DDC
....................          output_low(PIN_B2); 
2DC8:  BCF    F93.2
2DCA:  BCF    F8A.2
....................          delay_ms(500); 
2DCC:  MOVLW  02
2DCE:  MOVWF  xE4
2DD0:  MOVLW  FA
2DD2:  MOVWF  xE6
2DD4:  CALL   1494
2DD8:  DECFSZ xE4,F
2DDA:  BRA    2DD0
....................       } 
....................       if (cos_fi >= 0.97) { 
2DDC:  MOVLW  EC
2DDE:  MOVWF  xFB
2DE0:  MOVLW  51
2DE2:  MOVWF  xFA
2DE4:  MOVLW  78
2DE6:  MOVWF  xF9
2DE8:  MOVLW  7E
2DEA:  MOVWF  xF8
2DEC:  MOVFF  88,FF
2DF0:  MOVFF  87,FE
2DF4:  MOVFF  86,FD
2DF8:  MOVFF  85,FC
2DFC:  CALL   1AF0
2E00:  BC    2E04
2E02:  BNZ   2E18
....................          output_low(PIN_B3); 
2E04:  BCF    F93.3
2E06:  BCF    F8A.3
....................          delay_ms(500); 
2E08:  MOVLW  02
2E0A:  MOVWF  xE4
2E0C:  MOVLW  FA
2E0E:  MOVWF  xE6
2E10:  CALL   1494
2E14:  DECFSZ xE4,F
2E16:  BRA    2E0C
....................       } 
....................       if (cos_fi>= 0.97) { 
2E18:  MOVLW  EC
2E1A:  MOVWF  xFB
2E1C:  MOVLW  51
2E1E:  MOVWF  xFA
2E20:  MOVLW  78
2E22:  MOVWF  xF9
2E24:  MOVLW  7E
2E26:  MOVWF  xF8
2E28:  MOVFF  88,FF
2E2C:  MOVFF  87,FE
2E30:  MOVFF  86,FD
2E34:  MOVFF  85,FC
2E38:  CALL   1AF0
2E3C:  BC    2E40
2E3E:  BNZ   2E44
....................          output_low(PIN_B4); 
2E40:  BCF    F93.4
2E42:  BCF    F8A.4
....................       } 
....................       if (cos_fi>= 0.97) { 
2E44:  MOVLW  EC
2E46:  MOVWF  xFB
2E48:  MOVLW  51
2E4A:  MOVWF  xFA
2E4C:  MOVLW  78
2E4E:  MOVWF  xF9
2E50:  MOVLW  7E
2E52:  MOVWF  xF8
2E54:  MOVFF  88,FF
2E58:  MOVFF  87,FE
2E5C:  MOVFF  86,FD
2E60:  MOVFF  85,FC
2E64:  CALL   1AF0
2E68:  BC    2E6C
2E6A:  BNZ   2E80
....................          output_low(PIN_B5); 
2E6C:  BCF    F93.5
2E6E:  BCF    F8A.5
....................          delay_ms(500); 
2E70:  MOVLW  02
2E72:  MOVWF  xE4
2E74:  MOVLW  FA
2E76:  MOVWF  xE6
2E78:  CALL   1494
2E7C:  DECFSZ xE4,F
2E7E:  BRA    2E74
....................       } 
....................     // Realiza las operaciones necesarias para la accin de "quitar" 
....................   } 
2E80:  GOTO   3306 (RETURN)
.................... } 
....................  
.................... //Operaciones Funciones de membrecias 
.................... float triang(float x, float a, float m, float b){ 
....................   if(x<a || x>=b) 
*
26F4:  MOVFF  E7,FB
26F8:  MOVFF  E6,FA
26FC:  MOVFF  E5,F9
2700:  MOVFF  E4,F8
2704:  MOVFF  EB,FF
2708:  MOVFF  EA,FE
270C:  MOVFF  E9,FD
2710:  MOVFF  E8,FC
2714:  CALL   1AF0
2718:  BC    2742
271A:  MOVFF  F3,FB
271E:  MOVFF  F2,FA
2722:  MOVFF  F1,F9
2726:  MOVFF  F0,F8
272A:  MOVFF  E7,FF
272E:  MOVFF  E6,FE
2732:  MOVFF  E5,FD
2736:  MOVFF  E4,FC
273A:  CALL   1AF0
273E:  BC    2742
2740:  BNZ   274C
....................     return 0;  
2742:  CLRF   00
2744:  CLRF   01
2746:  CLRF   02
2748:  CLRF   03
274A:  BRA    2902
....................   if(x>=a && x<m) 
274C:  MOVFF  EB,FB
2750:  MOVFF  EA,FA
2754:  MOVFF  E9,F9
2758:  MOVFF  E8,F8
275C:  MOVFF  E7,FF
2760:  MOVFF  E6,FE
2764:  MOVFF  E5,FD
2768:  MOVFF  E4,FC
276C:  CALL   1AF0
2770:  BC    2774
2772:  BNZ   2828
2774:  MOVFF  E7,FB
2778:  MOVFF  E6,FA
277C:  MOVFF  E5,F9
2780:  MOVFF  E4,F8
2784:  MOVFF  EF,FF
2788:  MOVFF  EE,FE
278C:  MOVFF  ED,FD
2790:  MOVFF  EC,FC
2794:  CALL   1AF0
2798:  BNC   2828
....................     return(x-a)/(m-a); 
279A:  BSF    FD8.1
279C:  MOVFF  E7,FF
27A0:  MOVFF  E6,FE
27A4:  MOVFF  E5,FD
27A8:  MOVFF  E4,FC
27AC:  MOVFF  EB,103
27B0:  MOVFF  EA,102
27B4:  MOVFF  E9,101
27B8:  MOVFF  E8,100
27BC:  CALL   1876
27C0:  MOVFF  03,F7
27C4:  MOVFF  02,F6
27C8:  MOVFF  01,F5
27CC:  MOVFF  00,F4
27D0:  BSF    FD8.1
27D2:  MOVFF  EF,FF
27D6:  MOVFF  EE,FE
27DA:  MOVFF  ED,FD
27DE:  MOVFF  EC,FC
27E2:  MOVFF  EB,103
27E6:  MOVFF  EA,102
27EA:  MOVFF  E9,101
27EE:  MOVFF  E8,100
27F2:  CALL   1876
27F6:  CLRF   16
27F8:  BTFSC  FF2.7
27FA:  BSF    16.7
27FC:  BCF    FF2.7
27FE:  MOVFF  F7,117
2802:  MOVFF  F6,116
2806:  MOVFF  F5,115
280A:  MOVFF  F4,114
280E:  MOVFF  03,11B
2812:  MOVFF  02,11A
2816:  MOVFF  01,119
281A:  MOVFF  00,118
281E:  CALL   1268
2822:  BTFSC  16.7
2824:  BSF    FF2.7
2826:  BRA    2902
....................   if(x>=m && x<b) 
2828:  MOVFF  EF,FB
282C:  MOVFF  EE,FA
2830:  MOVFF  ED,F9
2834:  MOVFF  EC,F8
2838:  MOVFF  E7,FF
283C:  MOVFF  E6,FE
2840:  MOVFF  E5,FD
2844:  MOVFF  E4,FC
2848:  CALL   1AF0
284C:  BC    2850
284E:  BNZ   2902
2850:  MOVFF  E7,FB
2854:  MOVFF  E6,FA
2858:  MOVFF  E5,F9
285C:  MOVFF  E4,F8
2860:  MOVFF  F3,FF
2864:  MOVFF  F2,FE
2868:  MOVFF  F1,FD
286C:  MOVFF  F0,FC
2870:  CALL   1AF0
2874:  BNC   2902
....................     return(b-x)/(b-m);     
2876:  BSF    FD8.1
2878:  MOVFF  F3,FF
287C:  MOVFF  F2,FE
2880:  MOVFF  F1,FD
2884:  MOVFF  F0,FC
2888:  MOVFF  E7,103
288C:  MOVFF  E6,102
2890:  MOVFF  E5,101
2894:  MOVFF  E4,100
2898:  CALL   1876
289C:  MOVFF  03,F7
28A0:  MOVFF  02,F6
28A4:  MOVFF  01,F5
28A8:  MOVFF  00,F4
28AC:  BSF    FD8.1
28AE:  MOVFF  F3,FF
28B2:  MOVFF  F2,FE
28B6:  MOVFF  F1,FD
28BA:  MOVFF  F0,FC
28BE:  MOVFF  EF,103
28C2:  MOVFF  EE,102
28C6:  MOVFF  ED,101
28CA:  MOVFF  EC,100
28CE:  CALL   1876
28D2:  CLRF   16
28D4:  BTFSC  FF2.7
28D6:  BSF    16.7
28D8:  BCF    FF2.7
28DA:  MOVFF  F7,117
28DE:  MOVFF  F6,116
28E2:  MOVFF  F5,115
28E6:  MOVFF  F4,114
28EA:  MOVFF  03,11B
28EE:  MOVFF  02,11A
28F2:  MOVFF  01,119
28F6:  MOVFF  00,118
28FA:  CALL   1268
28FE:  BTFSC  16.7
2900:  BSF    FF2.7
2902:  GOTO   29E8 (RETURN)
....................      
.................... } 
.................... float trapz (float x,float a,float b,float c,float d){ 
....................   if(x<a || x>=d) 
*
248A:  MOVFF  E7,FB
248E:  MOVFF  E6,FA
2492:  MOVFF  E5,F9
2496:  MOVFF  E4,F8
249A:  MOVFF  EB,FF
249E:  MOVFF  EA,FE
24A2:  MOVFF  E9,FD
24A6:  MOVFF  E8,FC
24AA:  CALL   1AF0
24AE:  BC    24D8
24B0:  MOVFF  F7,FB
24B4:  MOVFF  F6,FA
24B8:  MOVFF  F5,F9
24BC:  MOVFF  F4,F8
24C0:  MOVFF  E7,FF
24C4:  MOVFF  E6,FE
24C8:  MOVFF  E5,FD
24CC:  MOVFF  E4,FC
24D0:  CALL   1AF0
24D4:  BC    24D8
24D6:  BNZ   24E2
....................     return 0; 
24D8:  CLRF   00
24DA:  CLRF   01
24DC:  CLRF   02
24DE:  CLRF   03
24E0:  BRA    26F2
....................   if(x>=a && x<b) 
24E2:  MOVFF  EB,FB
24E6:  MOVFF  EA,FA
24EA:  MOVFF  E9,F9
24EE:  MOVFF  E8,F8
24F2:  MOVFF  E7,FF
24F6:  MOVFF  E6,FE
24FA:  MOVFF  E5,FD
24FE:  MOVFF  E4,FC
2502:  CALL   1AF0
2506:  BC    250A
2508:  BNZ   25BE
250A:  MOVFF  E7,FB
250E:  MOVFF  E6,FA
2512:  MOVFF  E5,F9
2516:  MOVFF  E4,F8
251A:  MOVFF  EF,FF
251E:  MOVFF  EE,FE
2522:  MOVFF  ED,FD
2526:  MOVFF  EC,FC
252A:  CALL   1AF0
252E:  BNC   25BE
....................     return(x-a)/(b-a); 
2530:  BSF    FD8.1
2532:  MOVFF  E7,FF
2536:  MOVFF  E6,FE
253A:  MOVFF  E5,FD
253E:  MOVFF  E4,FC
2542:  MOVFF  EB,103
2546:  MOVFF  EA,102
254A:  MOVFF  E9,101
254E:  MOVFF  E8,100
2552:  CALL   1876
2556:  MOVFF  03,FB
255A:  MOVFF  02,FA
255E:  MOVFF  01,F9
2562:  MOVFF  00,F8
2566:  BSF    FD8.1
2568:  MOVFF  EF,FF
256C:  MOVFF  EE,FE
2570:  MOVFF  ED,FD
2574:  MOVFF  EC,FC
2578:  MOVFF  EB,103
257C:  MOVFF  EA,102
2580:  MOVFF  E9,101
2584:  MOVFF  E8,100
2588:  CALL   1876
258C:  CLRF   16
258E:  BTFSC  FF2.7
2590:  BSF    16.7
2592:  BCF    FF2.7
2594:  MOVFF  FB,117
2598:  MOVFF  FA,116
259C:  MOVFF  F9,115
25A0:  MOVFF  F8,114
25A4:  MOVFF  03,11B
25A8:  MOVFF  02,11A
25AC:  MOVFF  01,119
25B0:  MOVFF  00,118
25B4:  CALL   1268
25B8:  BTFSC  16.7
25BA:  BSF    FF2.7
25BC:  BRA    26F2
....................   if(x>=b && x<c) 
25BE:  MOVFF  EF,FB
25C2:  MOVFF  EE,FA
25C6:  MOVFF  ED,F9
25CA:  MOVFF  EC,F8
25CE:  MOVFF  E7,FF
25D2:  MOVFF  E6,FE
25D6:  MOVFF  E5,FD
25DA:  MOVFF  E4,FC
25DE:  CALL   1AF0
25E2:  BC    25E6
25E4:  BNZ   2618
25E6:  MOVFF  E7,FB
25EA:  MOVFF  E6,FA
25EE:  MOVFF  E5,F9
25F2:  MOVFF  E4,F8
25F6:  MOVFF  F3,FF
25FA:  MOVFF  F2,FE
25FE:  MOVFF  F1,FD
2602:  MOVFF  F0,FC
2606:  CALL   1AF0
260A:  BNC   2618
....................     return 1; 
260C:  MOVLW  7F
260E:  MOVWF  00
2610:  CLRF   01
2612:  CLRF   02
2614:  CLRF   03
2616:  BRA    26F2
....................   if(x>=c && x<d) 
2618:  MOVFF  F3,FB
261C:  MOVFF  F2,FA
2620:  MOVFF  F1,F9
2624:  MOVFF  F0,F8
2628:  MOVFF  E7,FF
262C:  MOVFF  E6,FE
2630:  MOVFF  E5,FD
2634:  MOVFF  E4,FC
2638:  CALL   1AF0
263C:  BC    2640
263E:  BNZ   26F2
2640:  MOVFF  E7,FB
2644:  MOVFF  E6,FA
2648:  MOVFF  E5,F9
264C:  MOVFF  E4,F8
2650:  MOVFF  F7,FF
2654:  MOVFF  F6,FE
2658:  MOVFF  F5,FD
265C:  MOVFF  F4,FC
2660:  CALL   1AF0
2664:  BNC   26F2
....................     return (d-x)/(d-c); 
2666:  BSF    FD8.1
2668:  MOVFF  F7,FF
266C:  MOVFF  F6,FE
2670:  MOVFF  F5,FD
2674:  MOVFF  F4,FC
2678:  MOVFF  E7,103
267C:  MOVFF  E6,102
2680:  MOVFF  E5,101
2684:  MOVFF  E4,100
2688:  CALL   1876
268C:  MOVFF  03,FB
2690:  MOVFF  02,FA
2694:  MOVFF  01,F9
2698:  MOVFF  00,F8
269C:  BSF    FD8.1
269E:  MOVFF  F7,FF
26A2:  MOVFF  F6,FE
26A6:  MOVFF  F5,FD
26AA:  MOVFF  F4,FC
26AE:  MOVFF  F3,103
26B2:  MOVFF  F2,102
26B6:  MOVFF  F1,101
26BA:  MOVFF  F0,100
26BE:  CALL   1876
26C2:  CLRF   16
26C4:  BTFSC  FF2.7
26C6:  BSF    16.7
26C8:  BCF    FF2.7
26CA:  MOVFF  FB,117
26CE:  MOVFF  FA,116
26D2:  MOVFF  F9,115
26D6:  MOVFF  F8,114
26DA:  MOVFF  03,11B
26DE:  MOVFF  02,11A
26E2:  MOVFF  01,119
26E6:  MOVFF  00,118
26EA:  CALL   1268
26EE:  BTFSC  16.7
26F0:  BSF    FF2.7
26F2:  RETURN 0
....................  
.................... } 
....................  
.................... float fuzzyAND(float r,float s){ 
....................   if(r<s) 
*
2906:  MOVFF  F3,FB
290A:  MOVFF  F2,FA
290E:  MOVFF  F1,F9
2912:  MOVFF  F0,F8
2916:  MOVFF  F7,FF
291A:  MOVFF  F6,FE
291E:  MOVFF  F5,FD
2922:  MOVFF  F4,FC
2926:  CALL   1AF0
292A:  BNC   2940
....................     return r; 
292C:  MOVFF  F0,00
2930:  MOVFF  F1,01
2934:  MOVFF  F2,02
2938:  MOVFF  F3,03
293C:  BRA    2950
293E:  BRA    2950
....................   else 
....................     return s; 
2940:  MOVFF  F4,00
2944:  MOVFF  F5,01
2948:  MOVFF  F6,02
294C:  MOVFF  F7,03
2950:  RETURN 0
.................... } 
....................       
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... int1 flag1 = 0; 
.................... //funciones de interrupcion 
.................... #INT_EXT 
.................... void RB0_ISR(){   //seal corriente 
....................    set_timer1(0); 
*
1228:  CLRF   FCF
122A:  CLRF   FCE
.................... } 
....................  
122C:  BCF    FF2.1
122E:  GOTO   006C
.................... #INT_ext1 
.................... void RB1_ISR(){  //seal voltaje; 
....................      
....................       //t1 = ((float)get_timer1()); ///divisor de tiempo no mover 
....................       t1 = ((float)get_timer1()/1936.8); ///divisor de tiempo no mover 
*
13C6:  MOVF   FCE,W
13C8:  MOVFF  FCF,03
13CC:  MOVLB  1
13CE:  MOVWF  x10
13D0:  MOVFF  FCF,111
13D4:  MOVLB  0
13D6:  RCALL  1232
13D8:  MOVFF  03,113
13DC:  MOVFF  02,112
13E0:  MOVFF  01,111
13E4:  MOVFF  00,110
13E8:  MOVFF  03,117
13EC:  MOVFF  02,116
13F0:  MOVFF  01,115
13F4:  MOVFF  00,114
13F8:  MOVLW  9A
13FA:  MOVLB  1
13FC:  MOVWF  x1B
13FE:  MOVLW  19
1400:  MOVWF  x1A
1402:  MOVLW  72
1404:  MOVWF  x19
1406:  MOVLW  89
1408:  MOVWF  x18
140A:  MOVLB  0
140C:  RCALL  1268
140E:  MOVFF  03,84
1412:  MOVFF  02,83
1416:  MOVFF  01,82
141A:  MOVFF  00,81
....................        
141E:  BCF    FF0.0
1420:  GOTO   006C
.................... } 
....................  
....................  
....................  
.................... void main(){ 
*
3042:  CLRF   FF8
3044:  BCF    FD0.7
3046:  BSF    07.7
3048:  CLRF   x84
304A:  CLRF   x83
304C:  CLRF   x82
304E:  CLRF   x81
3050:  BCF    x7C.1
3052:  CLRF   x88
3054:  CLRF   x87
3056:  CLRF   x86
3058:  CLRF   x85
305A:  CLRF   x8C
305C:  CLRF   x8B
305E:  CLRF   x8A
3060:  CLRF   x89
3062:  CLRF   x90
3064:  CLRF   x8F
3066:  CLRF   x8E
3068:  CLRF   x8D
306A:  CLRF   x94
306C:  CLRF   x93
306E:  CLRF   x92
3070:  CLRF   x91
3072:  MOVFF  88,BC
3076:  MOVFF  87,BB
307A:  MOVFF  86,BA
307E:  MOVFF  85,B9
3082:  BCF    x7C.2
3084:  MOVF   FC1,W
3086:  ANDLW  C0
3088:  IORLW  0F
308A:  MOVWF  FC1
308C:  MOVLW  07
308E:  MOVWF  FB4
3090:  BRA    30BE
3092:  DATA 03,00
3094:  DATA 1B,00
3096:  DATA 04,0C
3098:  DATA 02,00
309A:  DATA 7F,00
309C:  DATA 00,0D
309E:  DATA 00,95
30A0:  DATA 7F,00
30A2:  DATA 00,00
30A4:  DATA 7F,00
30A6:  DATA 00,00
30A8:  DATA 7F,00
30AA:  DATA 00,00
30AC:  DATA 7F,07
30AE:  DATA C0,00
30B0:  DATA 02,80
30B2:  DATA 7F,80
30B4:  DATA 0A,C0
30B6:  DATA 00,04
30B8:  DATA 80,7F
30BA:  DATA 80,00
30BC:  DATA 00,00
30BE:  MOVLW  00
30C0:  MOVWF  FF8
30C2:  MOVLW  30
30C4:  MOVWF  FF7
30C6:  MOVLW  92
30C8:  MOVWF  FF6
30CA:  TBLRD*+
30CC:  MOVF   FF5,W
30CE:  MOVWF  00
30D0:  XORLW  00
30D2:  BZ    30FA
30D4:  TBLRD*+
30D6:  MOVF   FF5,W
30D8:  MOVWF  01
30DA:  BTFSC  FE8.7
30DC:  BRA    30E8
30DE:  ANDLW  0F
30E0:  MOVWF  FEA
30E2:  TBLRD*+
30E4:  MOVFF  FF5,FE9
30E8:  BTFSC  01.6
30EA:  TBLRD*+
30EC:  BTFSS  01.6
30EE:  TBLRD*+
30F0:  MOVFF  FF5,FEE
30F4:  DCFSNZ 00,F
30F6:  BRA    30CA
30F8:  BRA    30EC
30FA:  CLRF   FF8
....................      
....................     //config gpios 
....................     set_tris_b(0b00000011); 
30FC:  MOVLW  03
30FE:  MOVWF  F93
....................      
....................     output_low(pin_b2); 
3100:  BCF    F93.2
3102:  BCF    F8A.2
....................     output_low(pin_b3); 
3104:  BCF    F93.3
3106:  BCF    F8A.3
....................     output_low(pin_b4); 
3108:  BCF    F93.4
310A:  BCF    F8A.4
....................     output_low(pin_b5); 
310C:  BCF    F93.5
310E:  BCF    F8A.5
....................     //iniciar lcd  
....................    lcd_init(); 
3110:  GOTO   15EC
3114:  CLRF   16
3116:  BTFSC  FF2.7
3118:  BSF    16.7
311A:  BCF    FF2.7
....................    usb_cdc_init(); 
311C:  CALL   0382
3120:  BTFSC  16.7
3122:  BSF    FF2.7
....................     setup_timer_1(T1_INTERNAL|T1_DIV_BY_8 );  //desborde del timer 64ms  los valores equivalen a micro segundo 
3124:  MOVLW  B5
3126:  MOVWF  FCD
....................     //congigurar interrupcioes 
....................     setup_adc(ADC_CLOCK_INTERNAL); 
3128:  MOVF   FC0,W
312A:  ANDLW  C0
312C:  IORLW  07
312E:  MOVWF  FC0
3130:  BSF    FC0.7
3132:  BSF    FC2.0
....................     setUP_adc_ports(AN0_TO_AN1); 
3134:  MOVF   FC1,W
3136:  ANDLW  C0
3138:  IORLW  0D
313A:  MOVWF  FC1
....................     set_adc_channel(0); 
313C:  MOVLW  00
313E:  MOVWF  01
3140:  MOVF   FC2,W
3142:  ANDLW  C3
3144:  IORWF  01,W
3146:  MOVWF  FC2
....................     ext_int_edge(INT_EXT | H_TO_L); 
3148:  BSF    FF1.6
....................     ext_int_edge(INT_EXT1 | H_TO_L); 
314A:  BSF    FF1.6
....................     enable_interrupts(INT_EXT); 
314C:  BSF    FF2.4
....................     enable_interrupts(INT_EXT1); 
314E:  BSF    FF0.3
....................     enable_interrupts(GLOBAL); 
3150:  MOVLW  C0
3152:  IORWF  FF2,F
....................     lcd_gotoxy(1,1); 
3154:  MOVLW  01
3156:  MOVWF  xE6
3158:  MOVWF  xE7
315A:  CALL   166C
....................    lcd_putc("iniciando..."); 
315E:  MOVLW  24
3160:  MOVWF  FF6
3162:  MOVLW  14
3164:  MOVWF  FF7
3166:  CALL   16DE
....................    delay_ms(1000); 
316A:  MOVLW  04
316C:  MOVWF  xD8
316E:  MOVLW  FA
3170:  MOVWF  xE6
3172:  CALL   1494
3176:  DECFSZ xD8,F
3178:  BRA    316E
....................    lcd_putc("\f"); 
317A:  MOVLW  32
317C:  MOVWF  FF6
317E:  MOVLW  14
3180:  MOVWF  FF7
3182:  CALL   16DE
....................         int i =0; 
3186:  CLRF   xD7
....................    while(true){ 
....................              usb_task(); 
3188:  GOTO   1720
....................              
....................             if(usb_enumerated()){ 
318C:  GOTO   1744
3190:  MOVF   01,F
3192:  BTFSC  FD8.2
3194:  BRA    3308
....................               Indice=get_indice(t1); 
3196:  MOVFF  84,DB
319A:  MOVFF  83,DA
319E:  MOVFF  82,D9
31A2:  MOVFF  81,D8
31A6:  CALL   1C5C
31AA:  CLRF   16
31AC:  BTFSC  FF2.7
31AE:  BSF    16.7
31B0:  BCF    FF2.7
31B2:  MOVLB  1
31B4:  CLRF   x11
31B6:  MOVFF  01,110
31BA:  MOVLB  0
31BC:  CALL   1232
31C0:  BTFSC  16.7
31C2:  BSF    FF2.7
31C4:  MOVFF  03,8C
31C8:  MOVFF  02,8B
31CC:  MOVFF  01,8A
31D0:  MOVFF  00,89
....................               valores(); 
31D4:  CALL   1CB8
....................               corriente_rms =corriente(); 
31D8:  CALL   1E8E
31DC:  MOVFF  03,94
31E0:  MOVFF  02,93
31E4:  MOVFF  01,92
31E8:  MOVFF  00,91
....................              // voltaje_rms=voltaje();   
....................               lcd_gotoxy(1,1); 
31EC:  MOVLW  01
31EE:  MOVWF  xE6
31F0:  MOVWF  xE7
31F2:  CALL   166C
....................               printf(lcd_putc,"pf=%.2f",cos_fi); 
31F6:  MOVLW  34
31F8:  MOVWF  FF6
31FA:  MOVLW  14
31FC:  MOVWF  FF7
31FE:  MOVLW  03
3200:  MOVWF  xD8
3202:  CALL   2028
3206:  MOVLW  89
3208:  MOVWF  FE9
320A:  MOVFF  88,DB
320E:  MOVFF  87,DA
3212:  MOVFF  86,D9
3216:  MOVFF  85,D8
321A:  MOVLW  02
321C:  MOVWF  xDC
321E:  CALL   2114
....................               lcd_gotoxy(1,2); 
3222:  MOVLW  01
3224:  MOVWF  xE6
3226:  MOVLW  02
3228:  MOVWF  xE7
322A:  CALL   166C
....................               lcd_putc("USB conn         "); 
322E:  MOVLW  3C
3230:  MOVWF  FF6
3232:  MOVLW  14
3234:  MOVWF  FF7
3236:  CALL   16DE
....................               printf(usb_cdc_putc,"\rpf=%.2f t=%.3f I(A)=%.1f V= %.1f\n ",cos_fi,t1,corriente_rms,voltaje_rms); 
323A:  MOVLW  4E
323C:  MOVWF  FF6
323E:  MOVLW  14
3240:  MOVWF  FF7
3242:  MOVLW  04
3244:  MOVWF  xD8
3246:  CALL   22F2
324A:  MOVLW  89
324C:  MOVWF  FE9
324E:  MOVFF  88,DB
3252:  MOVFF  87,DA
3256:  MOVFF  86,D9
325A:  MOVFF  85,D8
325E:  MOVLW  02
3260:  MOVWF  xDC
3262:  CALL   2310
3266:  MOVLW  56
3268:  MOVWF  FF6
326A:  MOVLW  14
326C:  MOVWF  FF7
326E:  MOVLW  03
3270:  MOVWF  xD8
3272:  CALL   22F2
3276:  MOVLW  89
3278:  MOVWF  FE9
327A:  MOVFF  84,DB
327E:  MOVFF  83,DA
3282:  MOVFF  82,D9
3286:  MOVFF  81,D8
328A:  MOVLW  03
328C:  MOVWF  xDC
328E:  CALL   2310
3292:  MOVLW  5D
3294:  MOVWF  FF6
3296:  MOVLW  14
3298:  MOVWF  FF7
329A:  MOVLW  06
329C:  MOVWF  xD8
329E:  CALL   22F2
32A2:  MOVLW  89
32A4:  MOVWF  FE9
32A6:  MOVFF  94,DB
32AA:  MOVFF  93,DA
32AE:  MOVFF  92,D9
32B2:  MOVFF  91,D8
32B6:  MOVLW  01
32B8:  MOVWF  xDC
32BA:  CALL   2310
32BE:  MOVLW  67
32C0:  MOVWF  FF6
32C2:  MOVLW  14
32C4:  MOVWF  FF7
32C6:  MOVLW  04
32C8:  MOVWF  xD8
32CA:  CALL   22F2
32CE:  MOVLW  89
32D0:  MOVWF  FE9
32D2:  MOVFF  90,DB
32D6:  MOVFF  8F,DA
32DA:  MOVFF  8E,D9
32DE:  MOVFF  8D,D8
32E2:  MOVLW  01
32E4:  MOVWF  xDC
32E6:  CALL   2310
32EA:  MOVLW  0A
32EC:  MOVWF  xE5
32EE:  CALL   22E0
32F2:  MOVLW  20
32F4:  MOVWF  xE5
32F6:  CALL   22E0
....................               delay_ms(10); 
32FA:  MOVLW  0A
32FC:  MOVWF  xE6
32FE:  CALL   1494
....................               //lcd_gotoxy(1,2); 
....................               ///printf(lcd_putc,"A=%.2f",corriente_rms ); 
....................               difuso(); 
3302:  GOTO   2952
....................           } 
3306:  BRA    342E
....................           else{ 
....................                
....................               Indice=get_indice(t1); 
3308:  MOVFF  84,DB
330C:  MOVFF  83,DA
3310:  MOVFF  82,D9
3314:  MOVFF  81,D8
3318:  CALL   1C5C
331C:  CLRF   16
331E:  BTFSC  FF2.7
3320:  BSF    16.7
3322:  BCF    FF2.7
3324:  MOVLB  1
3326:  CLRF   x11
3328:  MOVFF  01,110
332C:  MOVLB  0
332E:  CALL   1232
3332:  BTFSC  16.7
3334:  BSF    FF2.7
3336:  MOVFF  03,8C
333A:  MOVFF  02,8B
333E:  MOVFF  01,8A
3342:  MOVFF  00,89
....................               valores(); 
3346:  CALL   1CB8
....................               corriente_rms =corriente(); 
334A:  CALL   1E8E
334E:  MOVFF  03,94
3352:  MOVFF  02,93
3356:  MOVFF  01,92
335A:  MOVFF  00,91
....................               voltaje_rms=voltaje();          
335E:  BRA    2E84
3360:  MOVFF  03,90
3364:  MOVFF  02,8F
3368:  MOVFF  01,8E
336C:  MOVFF  00,8D
....................               lcd_gotoxy(1,1); 
3370:  MOVLW  01
3372:  MOVWF  xE6
3374:  MOVWF  xE7
3376:  CALL   166C
....................               printf(lcd_putc,"pf=%.2f\n",cos_fi); 
337A:  MOVLW  72
337C:  MOVWF  FF6
337E:  MOVLW  14
3380:  MOVWF  FF7
3382:  MOVLW  03
3384:  MOVWF  xD8
3386:  CALL   2028
338A:  MOVLW  89
338C:  MOVWF  FE9
338E:  MOVFF  88,DB
3392:  MOVFF  87,DA
3396:  MOVFF  86,D9
339A:  MOVFF  85,D8
339E:  MOVLW  02
33A0:  MOVWF  xDC
33A2:  CALL   2114
33A6:  MOVLW  0A
33A8:  MOVWF  xE5
33AA:  CALL   168E
....................               lcd_gotoxy(1,2); 
33AE:  MOVLW  01
33B0:  MOVWF  xE6
33B2:  MOVLW  02
33B4:  MOVWF  xE7
33B6:  CALL   166C
....................               printf(lcd_putc,"I(A)=%.1f\n",corriente_rms); 
33BA:  MOVLW  7C
33BC:  MOVWF  FF6
33BE:  MOVLW  14
33C0:  MOVWF  FF7
33C2:  MOVLW  05
33C4:  MOVWF  xD8
33C6:  CALL   2028
33CA:  MOVLW  89
33CC:  MOVWF  FE9
33CE:  MOVFF  94,DB
33D2:  MOVFF  93,DA
33D6:  MOVFF  92,D9
33DA:  MOVFF  91,D8
33DE:  MOVLW  01
33E0:  MOVWF  xDC
33E2:  CALL   2114
33E6:  MOVLW  0A
33E8:  MOVWF  xE5
33EA:  CALL   168E
....................               lcd_gotoxy(7,2); 
33EE:  MOVLW  07
33F0:  MOVWF  xE6
33F2:  MOVLW  02
33F4:  MOVWF  xE7
33F6:  CALL   166C
....................               printf(lcd_putc,"I(A)=%.1f\n",voltaje_rms); 
33FA:  MOVLW  88
33FC:  MOVWF  FF6
33FE:  MOVLW  14
3400:  MOVWF  FF7
3402:  MOVLW  05
3404:  MOVWF  xD8
3406:  CALL   2028
340A:  MOVLW  89
340C:  MOVWF  FE9
340E:  MOVFF  90,DB
3412:  MOVFF  8F,DA
3416:  MOVFF  8E,D9
341A:  MOVFF  8D,D8
341E:  MOVLW  01
3420:  MOVWF  xDC
3422:  CALL   2114
3426:  MOVLW  0A
3428:  MOVWF  xE5
342A:  CALL   168E
....................            
....................            
....................           } 
342E:  BRA    3188
....................             } 
....................              
....................     
.................... } 
....................  
3430:  SLEEP 
....................  
.................... int get_indice(float t1){ 
*
1C5C:  CLRF   xDC
....................   
....................      int indice=0; 
....................      indice= roundDecimal(t1*2); 
1C5E:  MOVFF  DB,ED
1C62:  MOVFF  DA,EC
1C66:  MOVFF  D9,EB
1C6A:  MOVFF  D8,EA
1C6E:  CLRF   xF1
1C70:  CLRF   xF0
1C72:  CLRF   xEF
1C74:  MOVLW  80
1C76:  MOVWF  xEE
1C78:  RCALL  174C
1C7A:  MOVFF  03,E0
1C7E:  MOVFF  02,DF
1C82:  MOVFF  01,DE
1C86:  MOVFF  00,DD
1C8A:  MOVFF  03,E4
1C8E:  MOVFF  02,E3
1C92:  MOVFF  01,E2
1C96:  MOVFF  00,E1
1C9A:  BRA    1B96
1C9C:  MOVFF  03,ED
1CA0:  MOVFF  02,EC
1CA4:  MOVFF  01,EB
1CA8:  MOVFF  00,EA
1CAC:  RCALL  183E
1CAE:  MOVFF  01,DC
....................       
....................       
....................       
....................       
....................       
....................      return indice;  //retorna el factor de potencia descrito en el arreglo 
1CB2:  MOVFF  DC,01
1CB6:  RETURN 0
.................... } 
....................  
....................  
.................... float roundDecimal(float num) { 
*
1B96:  MOVFF  E4,ED
1B9A:  MOVFF  E3,EC
1B9E:  MOVFF  E2,EB
1BA2:  MOVFF  E1,EA
1BA6:  RCALL  183E
1BA8:  MOVFF  01,E5
1BAC:  CLRF   16
1BAE:  BTFSC  FF2.7
1BB0:  BSF    16.7
1BB2:  BCF    FF2.7
1BB4:  MOVLB  1
1BB6:  CLRF   x11
1BB8:  MOVFF  E5,110
1BBC:  MOVLB  0
1BBE:  CALL   1232
1BC2:  BTFSC  16.7
1BC4:  BSF    FF2.7
1BC6:  BSF    FD8.1
1BC8:  MOVFF  E4,FF
1BCC:  MOVFF  E3,FE
1BD0:  MOVFF  E2,FD
1BD4:  MOVFF  E1,FC
1BD8:  MOVFF  03,103
1BDC:  MOVFF  02,102
1BE0:  MOVFF  01,101
1BE4:  MOVFF  00,100
1BE8:  RCALL  1876
1BEA:  MOVFF  03,E9
1BEE:  MOVFF  02,E8
1BF2:  MOVFF  01,E7
1BF6:  MOVFF  00,E6
....................     int entero = (int)num; 
....................     float decimal = num - entero; 
....................  
....................     // Redondear al entero ms cercano 
....................     if (decimal < 0.2) { 
1BFA:  MOVFF  E9,FB
1BFE:  MOVFF  E8,FA
1C02:  MOVFF  E7,F9
1C06:  MOVFF  E6,F8
1C0A:  MOVLW  CD
1C0C:  MOVWF  xFF
1C0E:  MOVLW  CC
1C10:  MOVWF  xFE
1C12:  MOVLW  4C
1C14:  MOVWF  xFD
1C16:  MOVLW  7C
1C18:  MOVWF  xFC
1C1A:  RCALL  1AF0
1C1C:  BNC   1C3C
1C1E:  CLRF   16
1C20:  BTFSC  FF2.7
1C22:  BSF    16.7
1C24:  BCF    FF2.7
....................         return (float)entero; 
1C26:  MOVLB  1
1C28:  CLRF   x11
1C2A:  MOVFF  E5,110
1C2E:  MOVLB  0
1C30:  CALL   1232
1C34:  BTFSC  16.7
1C36:  BSF    FF2.7
1C38:  BRA    1C58
....................     } else { 
1C3A:  BRA    1C58
....................         return (float)(entero + 1); 
1C3C:  MOVLW  01
1C3E:  ADDWF  xE5,W
1C40:  CLRF   16
1C42:  BTFSC  FF2.7
1C44:  BSF    16.7
1C46:  BCF    FF2.7
1C48:  MOVLB  1
1C4A:  CLRF   x11
1C4C:  MOVWF  x10
1C4E:  MOVLB  0
1C50:  CALL   1232
1C54:  BTFSC  16.7
1C56:  BSF    FF2.7
....................     } 
1C58:  GOTO   1C9C (RETURN)
.................... } 
....................  
....................  
....................  
.................... void valores(){ 
....................  
....................     switch((int)indice) { 
*
1CB8:  MOVFF  8C,ED
1CBC:  MOVFF  8B,EC
1CC0:  MOVFF  8A,EB
1CC4:  MOVFF  89,EA
1CC8:  RCALL  183E
1CCA:  MOVF   01,W
1CCC:  XORLW  01
1CCE:  BZ    1D3A
1CD0:  XORLW  03
1CD2:  BZ    1D46
1CD4:  XORLW  01
1CD6:  BZ    1D58
1CD8:  XORLW  07
1CDA:  BZ    1D68
1CDC:  XORLW  01
1CDE:  BZ    1D7A
1CE0:  XORLW  03
1CE2:  BZ    1D8C
1CE4:  XORLW  01
1CE6:  BZ    1D9A
1CE8:  XORLW  0F
1CEA:  BZ    1DAC
1CEC:  XORLW  01
1CEE:  BZ    1DBA
1CF0:  XORLW  03
1CF2:  BTFSC  FD8.2
1CF4:  BRA    1DCC
1CF6:  XORLW  01
1CF8:  BTFSC  FD8.2
1CFA:  BRA    1DDE
1CFC:  XORLW  07
1CFE:  BTFSC  FD8.2
1D00:  BRA    1DE8
1D02:  XORLW  01
1D04:  BTFSC  FD8.2
1D06:  BRA    1DF8
1D08:  XORLW  03
1D0A:  BTFSC  FD8.2
1D0C:  BRA    1E08
1D0E:  XORLW  01
1D10:  BTFSC  FD8.2
1D12:  BRA    1E18
1D14:  XORLW  1F
1D16:  BTFSC  FD8.2
1D18:  BRA    1E2A
1D1A:  XORLW  01
1D1C:  BTFSC  FD8.2
1D1E:  BRA    1E3A
1D20:  XORLW  03
1D22:  BTFSC  FD8.2
1D24:  BRA    1E4A
1D26:  XORLW  01
1D28:  BTFSC  FD8.2
1D2A:  BRA    1E5C
1D2C:  XORLW  07
1D2E:  BTFSC  FD8.2
1D30:  BRA    1E6C
1D32:  XORLW  01
1D34:  BTFSC  FD8.2
1D36:  BRA    1E7E
1D38:  BRA    1E8C
....................         case 1: 
....................             cos_fi=1.0; 
1D3A:  CLRF   x88
1D3C:  CLRF   x87
1D3E:  CLRF   x86
1D40:  MOVLW  7F
1D42:  MOVWF  x85
....................             break; 
1D44:  BRA    1E8C
....................         case 2: 
....................             cos_fi=0.98; 
1D46:  MOVLW  48
1D48:  MOVWF  x88
1D4A:  MOVLW  E1
1D4C:  MOVWF  x87
1D4E:  MOVLW  7A
1D50:  MOVWF  x86
1D52:  MOVLW  7E
1D54:  MOVWF  x85
....................             break; 
1D56:  BRA    1E8C
....................         case 3: 
....................             cos_fi=0.95; 
1D58:  MOVLW  33
1D5A:  MOVWF  x88
1D5C:  MOVWF  x87
1D5E:  MOVLW  73
1D60:  MOVWF  x86
1D62:  MOVLW  7E
1D64:  MOVWF  x85
....................             break; 
1D66:  BRA    1E8C
....................         case 4: 
....................            cos_fi=0.89; 
1D68:  MOVLW  0A
1D6A:  MOVWF  x88
1D6C:  MOVLW  D7
1D6E:  MOVWF  x87
1D70:  MOVLW  63
1D72:  MOVWF  x86
1D74:  MOVLW  7E
1D76:  MOVWF  x85
....................             break; 
1D78:  BRA    1E8C
....................         case 5: 
....................             cos_fi=0.80; 
1D7A:  MOVLW  CD
1D7C:  MOVWF  x88
1D7E:  MOVLW  CC
1D80:  MOVWF  x87
1D82:  MOVLW  4C
1D84:  MOVWF  x86
1D86:  MOVLW  7E
1D88:  MOVWF  x85
....................             break; 
1D8A:  BRA    1E8C
....................         case 6: 
....................             cos_fi=0.70; 
1D8C:  MOVLW  33
1D8E:  MOVWF  x88
1D90:  MOVWF  x87
1D92:  MOVWF  x86
1D94:  MOVLW  7E
1D96:  MOVWF  x85
....................             break; 
1D98:  BRA    1E8C
....................         case 7: 
....................             cos_fi=0.58; 
1D9A:  MOVLW  E1
1D9C:  MOVWF  x88
1D9E:  MOVLW  7A
1DA0:  MOVWF  x87
1DA2:  MOVLW  14
1DA4:  MOVWF  x86
1DA6:  MOVLW  7E
1DA8:  MOVWF  x85
....................             break; 
1DAA:  BRA    1E8C
....................         case 8: 
....................             cos_fi=0.45; 
1DAC:  MOVLW  66
1DAE:  MOVWF  x88
1DB0:  MOVWF  x87
1DB2:  MOVWF  x86
1DB4:  MOVLW  7D
1DB6:  MOVWF  x85
....................             break; 
1DB8:  BRA    1E8C
....................         case 9: 
....................             cos_fi=0.30; 
1DBA:  MOVLW  9A
1DBC:  MOVWF  x88
1DBE:  MOVLW  99
1DC0:  MOVWF  x87
1DC2:  MOVLW  19
1DC4:  MOVWF  x86
1DC6:  MOVLW  7D
1DC8:  MOVWF  x85
....................             break; 
1DCA:  BRA    1E8C
....................         case 10: 
....................             cos_fi=0.15; 
1DCC:  MOVLW  9A
1DCE:  MOVWF  x88
1DD0:  MOVLW  99
1DD2:  MOVWF  x87
1DD4:  MOVLW  19
1DD6:  MOVWF  x86
1DD8:  MOVLW  7C
1DDA:  MOVWF  x85
....................             break; 
1DDC:  BRA    1E8C
....................         case 11: 
....................              cos_fi=0.0; 
1DDE:  CLRF   x88
1DE0:  CLRF   x87
1DE2:  CLRF   x86
1DE4:  CLRF   x85
....................              break; 
1DE6:  BRA    1E8C
....................         case 12: 
....................             cos_fi=-0.15; 
1DE8:  MOVLW  9A
1DEA:  MOVWF  x88
1DEC:  MOVLW  99
1DEE:  MOVWF  x87
1DF0:  MOVWF  x86
1DF2:  MOVLW  7C
1DF4:  MOVWF  x85
....................             break; 
1DF6:  BRA    1E8C
....................         case 13: 
....................            cos_fi=-0.30; 
1DF8:  MOVLW  9A
1DFA:  MOVWF  x88
1DFC:  MOVLW  99
1DFE:  MOVWF  x87
1E00:  MOVWF  x86
1E02:  MOVLW  7D
1E04:  MOVWF  x85
....................             break; 
1E06:  BRA    1E8C
....................         case 14: 
....................             cos_fi=-0.45; 
1E08:  MOVLW  66
1E0A:  MOVWF  x88
1E0C:  MOVWF  x87
1E0E:  MOVLW  E6
1E10:  MOVWF  x86
1E12:  MOVLW  7D
1E14:  MOVWF  x85
....................             break; 
1E16:  BRA    1E8C
....................         case 15: 
....................             cos_fi=-0.58; 
1E18:  MOVLW  E1
1E1A:  MOVWF  x88
1E1C:  MOVLW  7A
1E1E:  MOVWF  x87
1E20:  MOVLW  94
1E22:  MOVWF  x86
1E24:  MOVLW  7E
1E26:  MOVWF  x85
....................             break; 
1E28:  BRA    1E8C
....................         case 16: 
....................             cos_fi=-0.70; 
1E2A:  MOVLW  33
1E2C:  MOVWF  x88
1E2E:  MOVWF  x87
1E30:  MOVLW  B3
1E32:  MOVWF  x86
1E34:  MOVLW  7E
1E36:  MOVWF  x85
....................             break; 
1E38:  BRA    1E8C
....................              
....................         case 17: 
....................             cos_fi=-0.80; 
1E3A:  MOVLW  CD
1E3C:  MOVWF  x88
1E3E:  MOVLW  CC
1E40:  MOVWF  x87
1E42:  MOVWF  x86
1E44:  MOVLW  7E
1E46:  MOVWF  x85
....................             break; 
1E48:  BRA    1E8C
....................         case 18: 
....................             cos_fi=-0.89; 
1E4A:  MOVLW  0A
1E4C:  MOVWF  x88
1E4E:  MOVLW  D7
1E50:  MOVWF  x87
1E52:  MOVLW  E3
1E54:  MOVWF  x86
1E56:  MOVLW  7E
1E58:  MOVWF  x85
....................             break; 
1E5A:  BRA    1E8C
....................         case 19: 
....................             cos_fi=-0.95; 
1E5C:  MOVLW  33
1E5E:  MOVWF  x88
1E60:  MOVWF  x87
1E62:  MOVLW  F3
1E64:  MOVWF  x86
1E66:  MOVLW  7E
1E68:  MOVWF  x85
....................             break; 
1E6A:  BRA    1E8C
....................         case 20: 
....................             cos_fi=-0.98; 
1E6C:  MOVLW  48
1E6E:  MOVWF  x88
1E70:  MOVLW  E1
1E72:  MOVWF  x87
1E74:  MOVLW  FA
1E76:  MOVWF  x86
1E78:  MOVLW  7E
1E7A:  MOVWF  x85
....................             break; 
1E7C:  BRA    1E8C
....................         case 21: 
....................             cos_fi=-1.0; 
1E7E:  CLRF   x88
1E80:  CLRF   x87
1E82:  MOVLW  80
1E84:  MOVWF  x86
1E86:  MOVLW  7F
1E88:  MOVWF  x85
....................             break; 
1E8A:  BRA    1E8C
....................         default: 
....................              
....................             break; 
....................     } 
1E8C:  RETURN 0
.................... }     
....................  
....................  

Configuration Fuses:
   Word  1: CE30   PLL1 CPUDIV3 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8300   CCP2C1 PBADEN NOLPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
